diff -Naur openvswitch-2.3.2/include/openflow/openflow-1.1.h umon_ovs2.3/include/openflow/openflow-1.1.h
--- openvswitch-2.3.2/include/openflow/openflow-1.1.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/include/openflow/openflow-1.1.h	2016-06-23 10:04:04.914455351 -0400
@@ -49,6 +49,25 @@
 
 /* OpenFlow: protocol between controller and datapath. */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OPENFLOW_11_H
 #define OPENFLOW_11_H 1
 
@@ -175,6 +194,18 @@
     OFPGC11_DELETE,       /* Delete all matching groups. */
 };
 
+/* UMON: monitor table modifications */
+/* Monitor Table Modification Commands */
+enum ofp11_monitor_mod_command {
+   OFPMMC_ADD,          /* New rule. */
+   OFPMMC_MODIFY,        /* Modify all matching rules. */
+   OFPMMC_MODIFY_STRICT,        /*  Modify entry strictly matching wildcards. */
+   OFPMMC_DELETE,       /*  Delete all matching rules. */
+   OFPMMC_DELETE_STRICT,        /* Strictly match wildcards. */
+   OFPMMC_DELETE_MICFLOWS,	/* Delete all micflows of matching monitor rules. */
+};
+
+
 /* OpenFlow 1.1 specific capabilities supported by the datapath (struct
  * ofp_switch_features, member capabilities). */
 enum ofp11_capabilities {
@@ -210,10 +241,16 @@
     OFPAT11_GROUP,            /* Apply group. */
     OFPAT11_SET_NW_TTL,       /* IP TTL. */
     OFPAT11_DEC_NW_TTL,       /* Decrement IP TTL. */
+    /* UMON: monitor table modifications. */
+    OFPAT11_MONITOR = 28,               /* Monitor flaged packets and subflows. */
+    OFPAT11_PRTSCAN_DETECTION = 29,     /* Run port scanning attack detections. */
+
     OFPAT11_EXPERIMENTER = 0xffff
 };
 
 #define OFPMT11_STANDARD_LENGTH 88
+/* UMON: monitor table modifications*/
+#define OFPMT11_MONITOR_LENGTH 60
 
 struct ofp11_match_header {
     ovs_be16 type;             /* One of OFPMT_* */
@@ -250,6 +287,29 @@
 };
 OFP_ASSERT(sizeof(struct ofp11_match) == OFPMT11_STANDARD_LENGTH);
 
+/* UMON: monitor table modifications */
+/* Fields to match monitor rules against flows */
+struct ofp11_monitor_match {
+        struct ofp11_match_header omh;
+	ovs_be32 in_port;	/* Input switch port. */
+        ovs_be32 wildcards;     /* Wildcard fields. */
+        uint8_t dl_src[OFP_ETH_ALEN]; /* Ethernet source address. */
+        uint8_t dl_src_mask[OFP_ETH_ALEN]; /* Ethernet source address mask.  */
+        uint8_t dl_dst[OFP_ETH_ALEN]; /* Ethernet destination address. */
+        uint8_t dl_dst_mask[OFP_ETH_ALEN]; /* Ethernet destination address mask. */
+        ovs_be16 dl_type;          /* Ethernet frame type. */
+        uint8_t nw_tos;            /* IP ToS (actually DSCP field, 6 bits). */
+        uint8_t nw_proto;          /* IP protocol or lower 8 bits of ARP opcode. */
+        ovs_be32 nw_src;           /* IP source address. */
+        ovs_be32 nw_src_mask;      /* IP source address mask. */
+        ovs_be32 nw_dst;           /* IP destination address. */
+        ovs_be32 nw_dst_mask;      /* IP destination address mask. */
+        ovs_be16 tp_src;           /* TCP/UDP/SCTP source port. */
+        ovs_be16 tp_dst;           /* TCP/UDP/SCTP destination port. */
+};
+OFP_ASSERT(sizeof(struct ofp11_monitor_match) == OFPMT11_MONITOR_LENGTH);
+
+
 /* Flow wildcards. */
 enum ofp11_flow_wildcards {
     OFPFW11_IN_PORT     = 1 << 0,  /* Switch input port. */
@@ -365,6 +425,30 @@
 };
 OFP_ASSERT(sizeof(struct ofp11_action_group) == 8);
 
+/* UMON : monitor table modifications. */
+/* Action structure for OFPAT11_MONITOR*/
+struct ofp11_action_monitor {
+        ovs_be16 type;  /* Type. */
+        ovs_be16 len;   /* Length is padded to 64 bits. */
+        ovs_be32 monitor_flag;  /* One of OFPMT11_*. */
+        uint8_t subflow_flag;   /* 0 represents no subflow monitoring; 1 otherwise. */
+        uint8_t pad[3];
+        struct ofp11_match_header subflow; /* Struct ofp11_monitor_match matches for subflow monitoring. */
+};
+OFP_ASSERT(sizeof(struct ofp11_action_monitor) == 16);
+
+/* UMON: monitor table modifications */
+/* Action structure for OFPAT11_PRTSCAN_DETECTION. */
+struct ofp11_action_prtscan_detection {
+        ovs_be16 type;  /* Type. */
+        ovs_be16 len;   /* Length is 16. */
+        uint8_t pad[3];
+        uint8_t detector_switch;/* Switch on/off anomaly detections. */
+        ovs_be64 interval;      /* Anomaly detection interval (seconds). */
+};
+OFP_ASSERT(sizeof(struct ofp11_action_prtscan_detection) == 16);
+
+
 /* OFPAT_SET_QUEUE action struct: send packets to given queue on port. */
 struct ofp11_action_set_queue {
     ovs_be16 type;                    /* OFPAT11_SET_QUEUE. */
@@ -482,6 +566,26 @@
     OFPGT11_FF        /* Fast failover group. */
 };
 
+/* UMON: monitor table modifications */
+/* Monitor types.*/
+enum ofp11_monitor_type {
+    OFPMT11_NONE = 0,		 /* No monitor flaged packets. */
+    OFPMT11_FIN = 1 << 0,        /* Monitor TCP FIN packets. */
+    OFPMT11_SYN = 1 << 1,        /* Monitor TCP SYN packets. */
+    OFPMT11_ACK = 1 << 2,        /* Monitor TCP ACK packets. */
+    OFPMT11_RST = 1 << 3,        /* Monitor TCP RST packets. */
+    OFPMT11_FINACK = 1 << 4,     /* Monitor TCP FIN/ACK packets. */
+    OFPMT11_SYNACK = 1 << 5,     /* Monitor TCP SYN/ACK packets. */
+    OFPMT11_RSTACK = 1 << 6,     /* Monitor TCP RST/ACK packets. */
+    OFPMT11_ICMP_ECHOREQ = 1 << 7,       /* Monitor ICMP echo request packets. */
+    OFPMT11_ICMP_ECHOREP = 1 << 8       /* Monitor ICMP echo reply packets. */
+};
+
+enum ofp11_monitor_requst_type {
+    OFPMR_ALL = 0,	/* Fetch stats from all monitor rules. */
+    OFPMR_EXACT = 1	/* Fetch stats for a specific monitor rule. */
+};
+
 /* Group numbering. Groups can use any number up to OFPG_MAX. */
 enum ofp11_group {
     /* Last usable group number. */
@@ -524,6 +628,30 @@
 };
 OFP_ASSERT(sizeof(struct ofp11_queue_get_config_reply) == 8);
 
+/* UMON: monitor table modifications */
+struct ofp11_monitor_mod {
+        uint8_t command;        /* One of OFPMMC_*. */
+        uint8_t pad[3];
+        ovs_be16 idle_timeout;  /* Idle time before discarding (seconds). Unused*/
+        ovs_be16 hard_timeout;  /* Max time before discarding (seconds). Unused*/
+        /* Followed by an ofp11_monitor_match structure. */
+        /* Followed by an instruction set. Only allow apply actions. */
+};
+OFP_ASSERT(sizeof(struct ofp11_monitor_mod) == 8);
+
+/* UMON: monitor stats request. */
+struct ofp11_monitor_stats_request {
+        uint8_t with_subflows;  /* boolean. 0 if not request subflows; 1 otherwise. */
+        uint8_t type;   /* One of OFPMR_*. 1 if request exact match rule from monitor table; 0 requests entire monitor table. */
+        uint8_t pad[2];
+	ovs_be32 request_id;	/* Link stats request with multiple replies. */
+	ovs_be32 pkt_threshold;	/* packet count threshold for micflow. */
+	ovs_be32 byte_threshold;	/* byte count threshold for micflow. */
+        /* Followed by an ofp11_monitor_match structure for exact match rule request. */
+};
+OFP_ASSERT(sizeof(struct ofp11_monitor_stats_request) == 16);
+
+
 struct ofp11_stats_msg {
     struct ofp_header header;
     ovs_be16 type;              /* One of the OFPST_* constants. */
@@ -587,6 +715,37 @@
 };
 OFP_ASSERT(sizeof(struct ofp11_flow_stats) == 48);
 
+/* UMON: monitor stats request */
+struct ofp11_monitor_stats {
+    ovs_be16 length;	/* Length of this entry. */
+    uint8_t pad[2];
+    ovs_be32 request_id;	
+    ovs_be32 duration_sec;
+    ovs_be32 duration_nsec;
+    
+    ovs_be32 idle_age;
+    ovs_be32 hard_age;
+    uint8_t stat_count;
+    uint8_t pad2[1];
+    ovs_be16 n_micflows;
+    /* Monitor match */
+    /* uint64_t monitor_stats[] */
+    /* struct ofp11_monitor_micflow flows[] */
+};
+OFP_ASSERT(sizeof(struct ofp11_monitor_stats) == 28);
+
+/* UMON: monitor stats request. */
+struct ofp11_monitor_micflow {
+    ovs_be16 length;	/* Length of this entry. */
+    uint8_t pad[6];
+    ovs_be64 packet_count;	/* Number of packets in micflow. */
+    ovs_be64 byte_count;	/* Number of bytes in micflow. */
+    ovs_be32 duration_sec;	/* Duration of micflow. */
+    ovs_be32 duration_nsec;	
+    /* Micflow match, struct ofp_match_header */
+};
+OFP_ASSERT(sizeof(struct ofp11_monitor_micflow) == 32);
+
 /* Body for ofp_stats_request of type OFPST_AGGREGATE. */
 /* Identical to ofp11_flow_stats_request */
 
diff -Naur openvswitch-2.3.2/include/openflow/openflow-1.3.h umon_ovs2.3/include/openflow/openflow-1.3.h
--- openvswitch-2.3.2/include/openflow/openflow-1.3.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/include/openflow/openflow-1.3.h	2016-06-23 10:05:55.646188620 -0400
@@ -34,6 +34,25 @@
 
 /* OpenFlow: protocol between controller and datapath. */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OPENFLOW_13_H
 #define OPENFLOW_13_H 1
 
@@ -121,7 +140,10 @@
     OFPAT13_DEC_NW_TTL   = 24,  /* Decrement IP TTL. */
     OFPAT13_SET_FIELD    = 25,  /* Set a header field using OXM TLV format. */
     OFPAT13_PUSH_PBB     = 26,  /* Push a new PBB service tag (I-TAG) */
-    OFPAT13_POP_PBB      = 27   /* Pop the outer PBB service tag (I-TAG) */
+    OFPAT13_POP_PBB      = 27,   /* Pop the outer PBB service tag (I-TAG) */
+    /* UMON: monitor table modifications */
+    OFPAT13_MONITOR = 28,               /* Monitor TCP flaged packets. */
+    OFPAT13_PRTSCAN_DETECTION = 29     /* Run port scanning attack detections. */
 };
 
 /* enum ofp_config_flags value OFPC_INVALID_TTL_TO_CONTROLLER
diff -Naur openvswitch-2.3.2/include/openflow/openflow-common.h umon_ovs2.3/include/openflow/openflow-common.h
--- openvswitch-2.3.2/include/openflow/openflow-common.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/include/openflow/openflow-common.h	2016-06-23 10:06:17.750135843 -0400
@@ -47,6 +47,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OPENFLOW_COMMON_H
 #define OPENFLOW_COMMON_H 1
 
@@ -277,7 +296,8 @@
     OFPFC_MODIFY,           /* Modify all matching flows. */
     OFPFC_MODIFY_STRICT,    /* Modify entry strictly matching wildcards */
     OFPFC_DELETE,           /* Delete all matching flows. */
-    OFPFC_DELETE_STRICT     /* Strictly match wildcards and priority. */
+    OFPFC_DELETE_STRICT,     /* Strictly match wildcards and priority. */
+
 };
 
 enum ofp_flow_mod_flags {
@@ -426,6 +446,8 @@
     OFPMT_STANDARD = 0,         /* The match fields defined in the ofp11_match
                                    structure apply */
     OFPMT_OXM = 1,              /* OpenFlow Extensible Match */
+    /* UMON: monitor table modifications. */
+    OFPMT_MONITOR = 2,		/* Monitor Rule Match */
 };
 
 /* Group numbering. Groups can use any number up to OFPG_MAX. */
@@ -438,6 +460,7 @@
     OFPG_ANY        = 0xffffffff   /* Wildcard, for flow stats requests. */
 };
 
+
 /* Group configuration flags */
 enum ofp_group_capabilities {
     OFPGFC_SELECT_WEIGHT   = 1 << 0, /* Support weight for select groups */
diff -Naur openvswitch-2.3.2/lib/learning-switch.c umon_ovs2.3/lib/learning-switch.c
--- openvswitch-2.3.2/lib/learning-switch.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/learning-switch.c	2016-06-23 10:06:38.502087319 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "learning-switch.h"
 
@@ -407,6 +426,13 @@
     case OFPTYPE_TABLE_FEATURES_STATS_REPLY:
     case OFPTYPE_BUNDLE_CONTROL:
     case OFPTYPE_BUNDLE_ADD_MESSAGE:
+    /* UMON: monitor table modifications. */
+    case OFPTYPE_MONITOR_MOD:
+    /* UMON: prtscan detection alert. */
+    case OFPTYPE_PRTSCAN_ALERT:
+    /* UMON: monitor stats request. */
+    case OFPTYPE_MONITOR_STATS_REQUEST:
+    case OFPTYPE_MONITOR_STATS_REPLY:
     default:
         if (VLOG_IS_DBG_ENABLED()) {
             char *s = ofp_to_string(ofpbuf_data(msg), ofpbuf_size(msg), 2);
diff -Naur openvswitch-2.3.2/lib/netlink-socket.c umon_ovs2.3/lib/netlink-socket.c
--- openvswitch-2.3.2/lib/netlink-socket.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/netlink-socket.c	2016-06-23 10:07:13.686004167 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "netlink-socket.h"
 #include <errno.h>
@@ -122,7 +141,8 @@
     sock->protocol = protocol;
     sock->next_seq = 1;
 
-    rcvbuf = 1024 * 1024;
+    /* UMON: expand socket buffer size */
+    rcvbuf = 1024 * 1024 * 20;
     if (setsockopt(sock->fd, SOL_SOCKET, SO_RCVBUFFORCE,
                    &rcvbuf, sizeof rcvbuf)) {
         /* Only root can use SO_RCVBUFFORCE.  Everyone else gets EPERM.
diff -Naur openvswitch-2.3.2/lib/nx-match.c umon_ovs2.3/lib/nx-match.c
--- openvswitch-2.3.2/lib/nx-match.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/nx-match.c	2016-06-23 10:07:28.645966783 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 
 #include "nx-match.h"
@@ -116,9 +135,10 @@
     }
 }
 
+/* UMON: monitor table modifications. */
 static enum ofperr
 nx_pull_raw(const uint8_t *p, unsigned int match_len, bool strict,
-            struct match *match, ovs_be64 *cookie, ovs_be64 *cookie_mask)
+            struct match *match, ovs_be64 *cookie, ovs_be64 *cookie_mask, struct ofp11_match_header *omh)
 {
     uint32_t header;
 
@@ -145,7 +165,9 @@
             } else {
                 continue;
             }
-        } else if (!mf_are_prereqs_ok(mf, &match->flow)) {
+        }
+	/* UMON: monitor table modifications. */ 
+	else if (!mf_are_prereqs_ok(mf, &match->flow) && omh != NULL && omh->type != htons(OFPMT_MONITOR)) {
             error = OFPERR_OFPBMC_BAD_PREREQ;
         } else if (!mf_is_all_wild(mf, &match->wc)) {
             error = OFPERR_OFPBMC_DUP_FIELD;
@@ -221,7 +243,8 @@
         }
     }
 
-    return nx_pull_raw(p, match_len, strict, match, cookie, cookie_mask);
+    /* UMON: monitor table modifications. */
+    return nx_pull_raw(p, match_len, strict, match, cookie, cookie_mask, NULL);
 }
 
 /* Parses the nx_match formatted match description in 'b' with length
@@ -265,7 +288,8 @@
         return OFPERR_OFPBMC_BAD_LEN;
     }
 
-    if (omh->type != htons(OFPMT_OXM)) {
+    /* UMON: monitor table modifications. */
+    if (omh->type != htons(OFPMT_OXM) && omh->type != htons(OFPMT_MONITOR)) {
         return OFPERR_OFPBMC_BAD_TYPE;
     }
 
@@ -277,8 +301,9 @@
         return OFPERR_OFPBMC_BAD_LEN;
     }
 
+    /* UMON: monitor table modifications. */
     return nx_pull_raw(p + sizeof *omh, match_len - sizeof *omh,
-                       strict, match, NULL, NULL);
+                       strict, match, NULL, NULL, omh);
 }
 
 /* Parses the oxm formatted match description preceded by a struct
@@ -503,7 +528,7 @@
 nxm_put_ip(struct ofpbuf *b, const struct match *match, enum ofp_version oxm)
 {
     const struct flow *flow = &match->flow;
-
+    
     if (flow->dl_type == htons(ETH_TYPE_IP)) {
         nxm_put_32m(b, mf_oxm_header(MFF_IPV4_SRC, oxm),
                     flow->nw_src, match->wc.masks.nw_src);
@@ -595,6 +620,243 @@
     }
 }
 
+/* UMON: monitor stats request. */
+/* Appends to 'b' a set of OXM or NXM matches for the IPv4 or IPv6 fields in
+ * 'match'.  */
+static void
+nxm_put_monitor_ip(struct ofpbuf *b, const struct match *match, enum ofp_version oxm)
+{
+    const struct flow *flow = &match->flow;
+    
+    if (flow->dl_type == htons(ETH_TYPE_IP) || match->wc.masks.nw_src || match->wc.masks.nw_dst) {
+        nxm_put_32m(b, mf_oxm_header(MFF_IPV4_SRC, oxm),
+                    flow->nw_src, match->wc.masks.nw_src);
+        nxm_put_32m(b, mf_oxm_header(MFF_IPV4_DST, oxm),
+                    flow->nw_dst, match->wc.masks.nw_dst);
+    } else {
+        nxm_put_ipv6(b, mf_oxm_header(MFF_IPV6_SRC, oxm),
+                     &flow->ipv6_src, &match->wc.masks.ipv6_src);
+        nxm_put_ipv6(b, mf_oxm_header(MFF_IPV6_DST, oxm),
+                     &flow->ipv6_dst, &match->wc.masks.ipv6_dst);
+    }
+
+    nxm_put_frag(b, match);
+
+    if (match->wc.masks.nw_tos & IP_DSCP_MASK) {
+        if (oxm) {
+            nxm_put_8(b, mf_oxm_header(MFF_IP_DSCP_SHIFTED, oxm),
+                      flow->nw_tos >> 2);
+        } else {
+            nxm_put_8(b, mf_oxm_header(MFF_IP_DSCP, oxm),
+                      flow->nw_tos & IP_DSCP_MASK);
+        }
+    }
+
+    if (match->wc.masks.nw_tos & IP_ECN_MASK) {
+        nxm_put_8(b, mf_oxm_header(MFF_IP_ECN, oxm),
+                  flow->nw_tos & IP_ECN_MASK);
+    }
+
+    if (!oxm && match->wc.masks.nw_ttl) {
+        nxm_put_8(b, mf_oxm_header(MFF_IP_TTL, oxm), flow->nw_ttl);
+    }
+
+    nxm_put_32m(b, mf_oxm_header(MFF_IPV6_LABEL, oxm),
+                flow->ipv6_label, match->wc.masks.ipv6_label);
+
+    if (match->wc.masks.nw_proto) {
+        nxm_put_8(b, mf_oxm_header(MFF_IP_PROTO, oxm), flow->nw_proto);
+
+        if (flow->nw_proto == IPPROTO_TCP) {
+            nxm_put_16m(b, mf_oxm_header(MFF_TCP_SRC, oxm),
+                        flow->tp_src, match->wc.masks.tp_src);
+            nxm_put_16m(b, mf_oxm_header(MFF_TCP_DST, oxm),
+                        flow->tp_dst, match->wc.masks.tp_dst);
+            nxm_put_16m(b, mf_oxm_header(MFF_TCP_FLAGS, oxm),
+                        flow->tcp_flags, match->wc.masks.tcp_flags);
+        } else if (flow->nw_proto == IPPROTO_UDP) {
+            nxm_put_16m(b, mf_oxm_header(MFF_UDP_SRC, oxm),
+                        flow->tp_src, match->wc.masks.tp_src);
+            nxm_put_16m(b, mf_oxm_header(MFF_UDP_DST, oxm),
+                        flow->tp_dst, match->wc.masks.tp_dst);
+        } else if (flow->nw_proto == IPPROTO_SCTP) {
+            nxm_put_16m(b, mf_oxm_header(MFF_SCTP_SRC, oxm), flow->tp_src,
+                        match->wc.masks.tp_src);
+            nxm_put_16m(b, mf_oxm_header(MFF_SCTP_DST, oxm), flow->tp_dst,
+                        match->wc.masks.tp_dst);
+        } else if (is_icmpv4(flow)) {
+            if (match->wc.masks.tp_src) {
+                nxm_put_8(b, mf_oxm_header(MFF_ICMPV4_TYPE, oxm),
+                          ntohs(flow->tp_src));
+            }
+            if (match->wc.masks.tp_dst) {
+                nxm_put_8(b, mf_oxm_header(MFF_ICMPV4_CODE, oxm),
+                          ntohs(flow->tp_dst));
+            }
+        } else if (is_icmpv6(flow)) {
+            if (match->wc.masks.tp_src) {
+                nxm_put_8(b, mf_oxm_header(MFF_ICMPV6_TYPE, oxm),
+                          ntohs(flow->tp_src));
+            }
+            if (match->wc.masks.tp_dst) {
+                nxm_put_8(b, mf_oxm_header(MFF_ICMPV6_CODE, oxm),
+                          ntohs(flow->tp_dst));
+            }
+            if (flow->tp_src == htons(ND_NEIGHBOR_SOLICIT) ||
+                flow->tp_src == htons(ND_NEIGHBOR_ADVERT)) {
+                nxm_put_ipv6(b, mf_oxm_header(MFF_ND_TARGET, oxm),
+                             &flow->nd_target, &match->wc.masks.nd_target);
+                if (flow->tp_src == htons(ND_NEIGHBOR_SOLICIT)) {
+                    nxm_put_eth_masked(b, mf_oxm_header(MFF_ND_SLL, oxm),
+                                       flow->arp_sha, match->wc.masks.arp_sha);
+                }
+                if (flow->tp_src == htons(ND_NEIGHBOR_ADVERT)) {
+                    nxm_put_eth_masked(b, mf_oxm_header(MFF_ND_TLL, oxm),
+                                       flow->arp_tha, match->wc.masks.arp_tha);
+                }
+            }
+        }
+    }
+}
+
+/* UMON : monitor stats request */
+static int
+nx_put_monitor_raw(struct ofpbuf *b, enum ofp_version oxm, const struct match *match,
+           ovs_be64 cookie, ovs_be64 cookie_mask)
+{
+    const struct flow *flow = &match->flow;
+    const size_t start_len = ofpbuf_size(b);
+    int match_len;
+    int i;
+
+    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 26);
+
+    /* Metadata. */
+
+    if (match->wc.masks.dp_hash) {
+        if (!oxm) {
+            nxm_put_32m(b, NXM_NX_DP_HASH, htonl(flow->dp_hash),
+                        htonl(match->wc.masks.dp_hash));
+        }
+    }
+
+    if (match->wc.masks.recirc_id) {
+        if (!oxm) {
+            nxm_put_32(b, NXM_NX_RECIRC_ID, htonl(flow->recirc_id));
+        }
+    }
+
+    if (match->wc.masks.in_port.ofp_port) {
+        ofp_port_t in_port = flow->in_port.ofp_port;
+        if (oxm) {
+            nxm_put_32(b, mf_oxm_header(MFF_IN_PORT_OXM, oxm),
+                       ofputil_port_to_ofp11(in_port));
+        } else {
+            nxm_put_16(b, mf_oxm_header(MFF_IN_PORT, oxm),
+                       htons(ofp_to_u16(in_port)));
+        }
+    }
+
+    /* Ethernet. */
+    nxm_put_eth_masked(b, mf_oxm_header(MFF_ETH_SRC, oxm),
+                       flow->dl_src, match->wc.masks.dl_src);
+    nxm_put_eth_masked(b, mf_oxm_header(MFF_ETH_DST, oxm),
+                       flow->dl_dst, match->wc.masks.dl_dst);
+    nxm_put_16m(b, mf_oxm_header(MFF_ETH_TYPE, oxm),
+                ofputil_dl_type_to_openflow(flow->dl_type),
+                match->wc.masks.dl_type);
+
+    /* 802.1Q. */
+    if (oxm) {
+        ovs_be16 VID_CFI_MASK = htons(VLAN_VID_MASK | VLAN_CFI);
+        ovs_be16 vid = flow->vlan_tci & VID_CFI_MASK;
+        ovs_be16 mask = match->wc.masks.vlan_tci & VID_CFI_MASK;
+
+        if (mask == htons(VLAN_VID_MASK | VLAN_CFI)) {
+            nxm_put_16(b, mf_oxm_header(MFF_VLAN_VID, oxm), vid);
+        } else if (mask) {
+            nxm_put_16m(b, mf_oxm_header(MFF_VLAN_VID, oxm), vid, mask);
+        }
+
+        if (vid && vlan_tci_to_pcp(match->wc.masks.vlan_tci)) {
+            nxm_put_8(b, mf_oxm_header(MFF_VLAN_PCP, oxm),
+                      vlan_tci_to_pcp(flow->vlan_tci));
+        }
+
+    } else {
+        nxm_put_16m(b, mf_oxm_header(MFF_VLAN_TCI, oxm), flow->vlan_tci,
+                    match->wc.masks.vlan_tci);
+    }
+
+    /* MPLS. */
+    if (eth_type_mpls(flow->dl_type)) {
+        if (match->wc.masks.mpls_lse[0] & htonl(MPLS_TC_MASK)) {
+            nxm_put_8(b, mf_oxm_header(MFF_MPLS_TC, oxm),
+                      mpls_lse_to_tc(flow->mpls_lse[0]));
+        }
+
+        if (match->wc.masks.mpls_lse[0] & htonl(MPLS_BOS_MASK)) {
+            nxm_put_8(b, mf_oxm_header(MFF_MPLS_BOS, oxm),
+                      mpls_lse_to_bos(flow->mpls_lse[0]));
+        }
+
+        if (match->wc.masks.mpls_lse[0] & htonl(MPLS_LABEL_MASK)) {
+            nxm_put_32(b, mf_oxm_header(MFF_MPLS_LABEL, oxm),
+                       htonl(mpls_lse_to_label(flow->mpls_lse[0])));
+        }
+    }
+
+    /* L3. */
+    if (is_ip_any(flow) || match->wc.masks.nw_proto || match->wc.masks.nw_src || match->wc.masks.nw_dst) {
+        nxm_put_monitor_ip(b, match, oxm);
+    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||
+               flow->dl_type == htons(ETH_TYPE_RARP)) {
+        /* ARP. */
+        if (match->wc.masks.nw_proto) {
+            nxm_put_16(b, mf_oxm_header(MFF_ARP_OP, oxm),
+                       htons(flow->nw_proto));
+        }
+        nxm_put_32m(b, mf_oxm_header(MFF_ARP_SPA, oxm),
+                    flow->nw_src, match->wc.masks.nw_src);
+        nxm_put_32m(b, mf_oxm_header(MFF_ARP_TPA, oxm),
+                    flow->nw_dst, match->wc.masks.nw_dst);
+        nxm_put_eth_masked(b, mf_oxm_header(MFF_ARP_SHA, oxm),
+                           flow->arp_sha, match->wc.masks.arp_sha);
+        nxm_put_eth_masked(b, mf_oxm_header(MFF_ARP_THA, oxm),
+                           flow->arp_tha, match->wc.masks.arp_tha);
+    }
+
+    /* Tunnel ID. */
+    nxm_put_64m(b, mf_oxm_header(MFF_TUN_ID, oxm),
+                flow->tunnel.tun_id, match->wc.masks.tunnel.tun_id);
+
+    /* Other tunnel metadata. */
+    nxm_put_32m(b, mf_oxm_header(MFF_TUN_SRC, oxm),
+                flow->tunnel.ip_src, match->wc.masks.tunnel.ip_src);
+    nxm_put_32m(b, mf_oxm_header(MFF_TUN_DST, oxm),
+                flow->tunnel.ip_dst, match->wc.masks.tunnel.ip_dst);
+
+    /* Registers. */
+    for (i = 0; i < FLOW_N_REGS; i++) {
+        nxm_put_32m(b, mf_oxm_header(MFF_REG0 + i, oxm),
+                    htonl(flow->regs[i]), htonl(match->wc.masks.regs[i]));
+    }
+
+    /* Mark. */
+    nxm_put_32m(b, mf_oxm_header(MFF_PKT_MARK, oxm), htonl(flow->pkt_mark),
+                htonl(match->wc.masks.pkt_mark));
+
+    /* OpenFlow 1.1+ Metadata. */
+    nxm_put_64m(b, mf_oxm_header(MFF_METADATA, oxm),
+                flow->metadata, match->wc.masks.metadata);
+
+    /* Cookie. */
+    nxm_put_64m(b, NXM_NX_COOKIE, cookie, cookie_mask);
+
+    match_len = ofpbuf_size(b) - start_len;
+    return match_len;
+}
+
 /* Appends to 'b' the nx_match format that expresses 'match'.  For Flow Mod and
  * Flow Stats Requests messages, a 'cookie' and 'cookie_mask' may be supplied.
  * Otherwise, 'cookie_mask' should be zero.
@@ -620,6 +882,7 @@
     BUILD_ASSERT_DECL(FLOW_WC_SEQ == 26);
 
     /* Metadata. */
+
     if (match->wc.masks.dp_hash) {
         if (!oxm) {
             nxm_put_32m(b, NXM_NX_DP_HASH, htonl(flow->dp_hash),
@@ -795,6 +1058,30 @@
 
     return match_len;
 }
+
+/* UMON: monitor stats request */
+int 
+oxm_put_monitor_match(struct ofpbuf * b, const struct match *match, 
+		      enum ofp_version version)
+{
+    int match_len;
+    struct ofp11_match_header *omh;
+    size_t start_len = ofpbuf_size(b);
+    ovs_be64 cookie = htonll(0), cookie_mask = htonll(0);
+
+    ofpbuf_put_uninit(b, sizeof *omh);
+    match_len = (nx_put_monitor_raw(b, version, match, cookie, cookie_mask)
+                 + sizeof *omh);
+    ofpbuf_put_zeros(b, PAD_SIZE(match_len, 8));
+
+    omh = ofpbuf_at(b, start_len, sizeof *omh);
+    omh->type = htons(OFPMT_MONITOR);
+    omh->length = htons(match_len);
+
+    return match_len;
+
+}
+
 
 /* nx_match_to_string() and helpers. */
 
diff -Naur openvswitch-2.3.2/lib/nx-match.h umon_ovs2.3/lib/nx-match.h
--- openvswitch-2.3.2/lib/nx-match.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/nx-match.h	2016-06-23 10:07:40.285939219 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef NX_MATCH_H
 #define NX_MATCH_H 1
 
@@ -53,6 +72,8 @@
 int nx_put_match(struct ofpbuf *, const struct match *,
                  ovs_be64 cookie, ovs_be64 cookie_mask);
 int oxm_put_match(struct ofpbuf *, const struct match *, enum ofp_version);
+/* UMON: monitor stats request. */
+int oxm_put_monitor_match(struct ofpbuf *, const struct match *, enum ofp_version);
 
 char *nx_match_to_string(const uint8_t *, unsigned int match_len);
 char *oxm_match_to_string(const struct ofpbuf *, unsigned int match_len);
diff -Naur openvswitch-2.3.2/lib/ofp-actions.c umon_ovs2.3/lib/ofp-actions.c
--- openvswitch-2.3.2/lib/ofp-actions.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-actions.c	2016-06-23 10:08:01.117889865 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "ofp-actions.h"
 #include "bundle.h"
@@ -57,6 +76,10 @@
     struct ofp11_action_mpls_tc ofp11_mpls_tc;
     struct ofp11_action_mpls_ttl ofp11_mpls_ttl;
     struct ofp11_action_group group;
+    /* UMON: monitor table modifications. */
+    struct ofp11_action_monitor monitor;
+    struct ofp11_action_prtscan_detection prt_detection;
+
     struct ofp12_action_set_field set_field;
     struct nx_action_header nxa_header;
     struct nx_action_resubmit resubmit;
@@ -823,6 +846,98 @@
     return 0;
 }
 
+
+/* UMON: monitor table modifications. */
+static enum ofperr
+monitor_from_openflow(const struct ofp11_action_monitor *oam,
+                      struct ofpbuf *ofpacts)
+{
+        uint16_t oam_len = ntohs(oam->len);
+        uint16_t submatch_len = oam_len - 16;
+        enum ofperr error;
+        struct ofpact_monitor *monitor;
+        struct ofp11_monitor_match* ofm;
+
+        if(oam_len != ROUND_UP(sizeof *oam + submatch_len, 8)){
+                return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+        }
+        if(ntohl(oam->monitor_flag) != 0 && leftmost_1bit_idx(ntohl(oam->monitor_flag)) >= 9 ){
+                return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+        }
+
+	ofm = (struct ofp11_monitor_match*)(&oam->subflow);
+        monitor = ofpact_put_MONITOR(ofpacts);
+
+        if(oam->subflow_flag == 1) {
+                uint16_t match_len = ntohs(ofm->omh.length);
+                struct ofpbuf b;
+                struct match subflow_match;
+                ofpbuf_use_const(&b, ofm, ROUND_UP(match_len,8));
+                if(ntohs(ofm->omh.type) != OFPMT_MONITOR){
+                        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+                }
+                error = ofputil_pull_ofp11_match(&b, &subflow_match, NULL);
+                if(error) {
+                        return error;
+                }
+                ofpbuf_put(ofpacts, &subflow_match, sizeof(subflow_match));
+                monitor = ofpacts->frame;
+                memcpy(&monitor->subflow_match, &subflow_match, sizeof(struct match));
+        }
+
+        monitor->monitor_flag = ntohl(oam->monitor_flag);
+        monitor->subflow_flag = oam->subflow_flag;
+        ofpact_update_len(ofpacts, &monitor->ofpact);
+
+        return 0;
+	
+}
+
+/* UMON: monitor table modifications. */
+static enum ofperr
+prtscan_from_openflow(const struct ofp11_action_prtscan_detection *oapd,
+                      struct ofpbuf *ofpacts)
+{
+	struct ofpbuf b;
+	struct match subflow_match;
+	enum ofperr error;
+	struct ofp11_monitor_match *ofm = (struct ofp11_monitor_match *)(&oapd->submatch);
+	uint16_t match_len;
+        uint64_t detection_interval = ntohll(oapd->interval);
+        struct ofpact_prtscan_detection *prtscan_detection;
+
+	if(oapd->delete_flows != 0 && oapd->delete_flows != 1) {
+		return OFPERR_OFPBAC_BAD_PRTSCAN_DELETE;
+	}
+        if(oapd->detector_switch != 0 && oapd->detector_switch != 1) {
+                return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+        }
+        if(detection_interval % 5 != 0) {
+                return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
+        }
+
+	prtscan_detection = ofpact_put_PRTSCAN_DETECTION(ofpacts);
+	match_len = ntohs(ofm->omh.length);
+	ofpbuf_use_const(&b, ofm, ROUND_UP(match_len, 8));
+	error = ofputil_pull_ofp11_match(&b, &subflow_match, NULL);
+	if(error) {
+	    return error;
+	}
+	ofpbuf_put(ofpacts, &subflow_match, sizeof(subflow_match));	
+	prtscan_detection = ofpacts->frame;
+	memcpy(&prtscan_detection->submatch, &subflow_match, sizeof(struct match));
+       
+        prtscan_detection->delete_flows = oapd->delete_flows; 
+        prtscan_detection->detector_switch = oapd->detector_switch;
+	prtscan_detection->detection_type = oapd->detection_type;
+	prtscan_detection->vthresh = ntohs(oapd->vthresh);
+	prtscan_detection->hthresh = ntohs(oapd->hthresh);
+        prtscan_detection->interval = ntohll(oapd->interval);
+	ofpact_update_len(ofpacts, &prtscan_detection->ofpact);
+
+        return 0;
+}
+
 static void
 set_field_to_openflow12(const struct ofpact_set_field *sf,
                         struct ofpbuf *openflow,
@@ -1270,6 +1385,17 @@
         ofpact_put_GROUP(out)->group_id = ntohl(a->group.group_id);
         break;
 
+    /* UMON: monitor table modifications. */
+    case OFPUTIL_OFPAT11_MONITOR:
+        return monitor_from_openflow(&a->monitor, out);
+        break;
+
+    /* UMON: monitor table modifications. */
+    case OFPUTIL_OFPAT11_PRTSCAN_DETECTION:
+        return prtscan_from_openflow(&a->prt_detection, out);
+        break;
+   
+
 #define NXAST_ACTION(ENUM, STRUCT, EXTENSIBLE, NAME) case OFPUTIL_##ENUM:
 #include "ofp-util.def"
         return ofpact_from_nxast(a, code, out);
@@ -1332,6 +1458,9 @@
     case OFPACT_STRIP_VLAN:
     case OFPACT_WRITE_ACTIONS:
     case OFPACT_WRITE_METADATA:
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
         return false;
     default:
         OVS_NOT_REACHED();
@@ -1399,6 +1528,9 @@
     case OFPACT_METER:
     case OFPACT_WRITE_ACTIONS:
     case OFPACT_WRITE_METADATA:
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
         return false;
     default:
         OVS_NOT_REACHED();
@@ -1590,6 +1722,9 @@
         return OVSINST_OFPIT11_GOTO_TABLE;
     case OFPACT_OUTPUT:
     case OFPACT_GROUP:
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
     case OFPACT_CONTROLLER:
     case OFPACT_ENQUEUE:
     case OFPACT_OUTPUT_REG:
@@ -2133,6 +2268,11 @@
     case OFPACT_GROUP:
         return 0;
 
+    /* UMON: monitor table modifications. */
+    case OFPACT_PRTSCAN_DETECTION:
+    case OFPACT_MONITOR:
+	return 0;
+
     default:
         OVS_NOT_REACHED();
     }
@@ -2476,6 +2616,10 @@
         break;
 
     case OFPACT_GROUP:
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
+
     case OFPACT_OUTPUT:
     case OFPACT_ENQUEUE:
     case OFPACT_SET_VLAN_VID:
@@ -2601,6 +2745,10 @@
 
     case OFPACT_GROUP:
         break;
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
+	break;
 
     case OFPACT_SET_FIELD:
         set_field_to_openflow(ofpact_get_SET_FIELD(a), out);
@@ -2665,6 +2813,7 @@
 static void
 ofpact_to_openflow11(const struct ofpact *a, struct ofpbuf *out)
 {
+    static struct ofp11_match submatch;
     switch (a->type) {
     case OFPACT_OUTPUT:
         return ofpact_output_to_openflow11(ofpact_get_OUTPUT(a), out);
@@ -2803,6 +2952,25 @@
         ofputil_put_OFPAT11_GROUP(out)->group_id =
             htonl(ofpact_get_GROUP(a)->group_id);
         break;
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+	ofputil_put_OFPAT11_MONITOR(out)->monitor_flag = 
+		htonl(ofpact_get_MONITOR(a)->monitor_flag);
+	ofputil_put_OFPAT11_MONITOR(out)->subflow_flag =
+		ofpact_get_MONITOR(a)->subflow_flag;
+	ofputil_match_to_ofp11_match(&ofpact_get_MONITOR(a)->subflow_match, &submatch);
+	ofputil_put_OFPAT11_MONITOR(out)->subflow = submatch.omh;
+	break;
+
+    /* UMON: monitor table modifications. */
+    case OFPACT_PRTSCAN_DETECTION:
+	ofputil_put_OFPAT11_PRTSCAN_DETECTION(out)->delete_flows = 
+		ofpact_get_PRTSCAN_DETECTION(a)->delete_flows;
+	ofputil_put_OFPAT11_PRTSCAN_DETECTION(out)->detector_switch = 
+		ofpact_get_PRTSCAN_DETECTION(a)->detector_switch;
+	ofputil_put_OFPAT11_PRTSCAN_DETECTION(out)->interval = 
+		htonll(ofpact_get_PRTSCAN_DETECTION(a)->interval);
+	break;
 
     case OFPACT_SET_FIELD:
         set_field_to_openflow(ofpact_get_SET_FIELD(a), out);
@@ -3152,6 +3320,9 @@
     case OFPACT_GOTO_TABLE:
     case OFPACT_METER:
     case OFPACT_GROUP:
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+    case OFPACT_PRTSCAN_DETECTION:
     default:
         return false;
     }
@@ -3286,6 +3457,10 @@
     const struct ofpact_sample *sample;
     const struct ofpact_set_field *set_field;
     const struct mf_field *mf;
+    /* UMON: monitor table modifications. */
+    const struct ofpact_monitor *monitor;
+    const struct ofpact_prtscan_detection *prtscan_detection;
+
     ofp_port_t port;
 
     switch (a->type) {
@@ -3576,6 +3751,24 @@
         ds_put_format(s, "group:%"PRIu32,
                       ofpact_get_GROUP(a)->group_id);
         break;
+
+    /* UMON: monitor table modifications. */
+    case OFPACT_MONITOR:
+        monitor = ofpact_get_MONITOR(a);
+        ds_put_format(s, "%s", ofputil_monitor_flag_to_string(monitor->monitor_flag));
+        if(monitor->subflow_flag == 1){
+                ds_put_format(s,", subflow monitor: %s", match_to_string(&monitor->subflow_match, OFP_DEFAULT_PRIORITY));
+        }
+        break;
+
+    /* UMON: monitor table modifications. */
+    case OFPACT_PRTSCAN_DETECTION:
+        prtscan_detection = ofpact_get_PRTSCAN_DETECTION(a);
+        if(prtscan_detection->detector_switch){
+                ds_put_format(s, "%s portscan detection on %s with interval: %lu", ofputil_prtscan_type_to_string(prtscan_detection->detection_type), match_to_string(&prtscan_detection->submatch, OFP_DEFAULT_PRIORITY), prtscan_detection->interval);
+        }
+        break;
+
     }
 }
 
diff -Naur openvswitch-2.3.2/lib/ofp-actions.h umon_ovs2.3/lib/ofp-actions.h
--- openvswitch-2.3.2/lib/ofp-actions.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-actions.h	2016-06-23 10:08:15.177855974 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFP_ACTIONS_H
 #define OFP_ACTIONS_H 1
 
@@ -57,7 +76,11 @@
     DEFINE_OFPACT(ENQUEUE,         ofpact_enqueue,       ofpact)    \
     DEFINE_OFPACT(OUTPUT_REG,      ofpact_output_reg,    ofpact)    \
     DEFINE_OFPACT(BUNDLE,          ofpact_bundle,        slaves)    \
-                                                                    \
+    /* UMON: monitor table modifications */                      \
+    /* Monitor Flags*/                                              \
+    DEFINE_OFPACT(MONITOR,      ofpact_monitor,         ofpact)     \
+    /* Portscan Detection*/                                         \
+    DEFINE_OFPACT(PRTSCAN_DETECTION,   ofpact_prtscan_detection,	ofpact)     							    	    \
     /* Header changes. */                                           \
     DEFINE_OFPACT(SET_FIELD,       ofpact_set_field,     ofpact)    \
     DEFINE_OFPACT(SET_VLAN_VID,    ofpact_vlan_vid,      ofpact)    \
@@ -210,6 +233,33 @@
     uint16_t max_len;           /* Max send len, for port OFPP_CONTROLLER. */
 };
 
+/* UMON: monitor table modifications */
+/* OFPACT_MONITOR.
+ *
+ * Used for OFPAT11_MONITOR. */
+struct ofpact_monitor {
+        struct ofpact ofpact;
+        uint32_t monitor_flag;  /* Monitor flags. */
+        uint8_t subflow_flag;  /* 0 represents no subflow monitoring; 1 otherwise. */
+        struct match subflow_match; /* Subflow match mask. */
+};
+
+/* UMON: monitor table modifications */
+/* OFPACT_PRTSCAN_DETECTION.
+ *
+ * Used for OFPAT10_PRTSCAN_DETECTION and OFPAT11_PRTSCAN_DETECTION. */
+struct ofpact_prtscan_detection {
+        struct ofpact ofpact;
+	uint8_t delete_flows;	/* Indicator of subflow deletion. */
+        uint8_t detector_switch;        /* Switch on/off anomaly detections. */
+        uint8_t detection_type;		/* port scanning attack detection type. */
+        uint64_t interval;      /* Anomaly detection interval (seconds). */
+	uint16_t vthresh;	/* Threshold of vertical scanning detection. */
+	uint16_t hthresh;	/* Threshold of horizontal scanning detection. */
+	struct match submatch; /* Subflow match mask. */
+};
+
+
 /* OFPACT_CONTROLLER.
  *
  * Used for NXAST_CONTROLLER. */
diff -Naur openvswitch-2.3.2/lib/ofp-errors.h umon_ovs2.3/lib/ofp-errors.h
--- openvswitch-2.3.2/lib/ofp-errors.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-errors.h	2016-06-23 10:08:28.349824151 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFP_ERRORS_H
 #define OFP_ERRORS_H 1
 
@@ -237,6 +256,26 @@
      * unsupported value, or modifies a read-only field. */
     OFPERR_OFPBAC_BAD_SET_ARGUMENT,
 
+    /* OF1.0+(2,200).  Action monitor uses unknown or unsupported type,
+     * UMON, monitor table modifications. */
+    OFPERR_OFPBAC_BAD_MONITOR_TYPE,
+
+    /* OF1.0+(2,201).  Action references past the end of an monitor_match, 
+     * or uses a length of zero. */
+    OFPERR_OFPBAC_BAD_MONITOR_LEN,
+
+    /* OF1.0+(2,202).  Action monitor set unknown or unsupported TCP flags. */
+    OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT,
+
+    /* OF1.0+(2,250).  Action portscan detection set unknown switch option. */
+    OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH,
+
+    /* OF1.0+(2,251).  Action portscan detection set invalid interval value. */
+    OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL,
+
+    /* OF1.0+(2,252).  Action portscan detection set unknown delete option. */
+    OFPERR_OFPBAC_BAD_PRTSCAN_DELETE,
+
     /* NX1.0-1.1(2,256), NX1.2+(11).  Must-be-zero action argument had nonzero
      * value. */
     OFPERR_NXBAC_MUST_BE_ZERO,
@@ -637,6 +676,24 @@
     /* OF1.4+(17,15).  Bundle is locking the resource. */
     OFPERR_OFPBFC_BUNDLE_IN_PROGRESS,
 
+/* ## ---------------------- ## */
+/* ## OFPET_MONITOR_MOD_FAILED ## */
+/* ## ---------------------- ## */
+
+    /* OF1.1+(200,0).  Monitor rule not added because a monitor ADD attempted to replace
+     * an already-present monitor rule. UMON.*/
+    OFPERR_OFPMMC_MONITOR_EXISTS,
+
+    /* OF1.1+(200,1).  Unsupported or unknown command. */
+    OFPERR_OFPMMC_BAD_COMMAND,
+
+    /* OF1.1+(200,2).  Attempted to add overlapping monitor rules. */
+    OFPERR_OFPMMC_OVERLAP,
+
+    /* OF1.1+(200,3).  Attempted to add overlapping monitor rules. */
+    OFPERR_OFPMMC_TABLE_FULL,
+
+
 /* ## ------------------ ## */
 /* ## OFPET_EXPERIMENTER ## */
 /* ## ------------------ ## */
diff -Naur openvswitch-2.3.2/lib/ofp-errors.inc umon_ovs2.3/lib/ofp-errors.inc
--- openvswitch-2.3.2/lib/ofp-errors.inc	2015-06-18 15:33:03.000000000 -0400
+++ umon_ovs2.3/lib/ofp-errors.inc	2016-03-16 11:03:30.090321611 -0400
@@ -1,6 +1,6 @@
 /* Generated automatically; do not modify!     -*- buffer-read-only: t -*- */
 
-#define OFPERR_N_ERRORS 148
+#define OFPERR_N_ERRORS 157
 
 struct ofperr_domain {
     const char *name;
@@ -51,6 +51,11 @@
     "OFPBAC_BAD_SET_TYPE",
     "OFPBAC_BAD_SET_LEN",
     "OFPBAC_BAD_SET_ARGUMENT",
+    "OFPBAC_BAD_MONITOR_TYPE",
+    "OFPBAC_BAD_MONITOR_LEN",
+    "OFPBAC_BAD_MONITOR_ARGUMENT",
+    "OFPBAC_BAD_PRTSCAN_SWITCH",
+    "OFPBAC_BAD_PRTSCAN_INTERVAL",
     "NXBAC_MUST_BE_ZERO",
     "OFPBIC_UNKNOWN_INST",
     "OFPBIC_UNSUP_INST",
@@ -158,6 +163,10 @@
     "OFPBFC_MSG_FAILED",
     "OFPBFC_TIMEOUT",
     "OFPBFC_BUNDLE_IN_PROGRESS",
+    "OFPMMC_MONITOR_EXISTS",
+    "OFPMMC_BAD_COMMAND",
+    "OFPMMC_OVERLAP",
+    "OFPMMC_TABLE_FULL",
 };
 
 static const char *error_comments[OFPERR_N_ERRORS] = {
@@ -202,6 +211,11 @@
     "Action uses unknown or unsupported OXM or NXM field.",
     "Action references past the end of an OXM or NXM field, or uses a length of zero.",
     "Action sets a field to an invalid or unsupported value, or modifies a read-only field.",
+    "Action monitor uses unknown or unsupported type, UMON, monitor table modifications.",
+    "Action references past the end of an monitor_match, or uses a length of zero.",
+    "Action monitor set unknown or unsupported TCP flags.",
+    "Action portscan detection set unknown switch option.",
+    "Action portscan detection set invalid interval value.",
     "Must-be-zero action argument had nonzero value.",
     "Unknown instruction.",
     "Switch or table does not support the instruction.",
@@ -309,6 +323,10 @@
     "One message in bundle failed.",
     "Bundle is taking too long.",
     "Bundle is locking the resource.",
+    "Monitor rule not added because a monitor ADD attempted to replace an already-present monitor rule. UMON.",
+    "Unsupported or unknown command.",
+    "Attempted to add overlapping monitor rules.",
+    "Attempted to add overlapping monitor rules.",
 };
 
 static enum ofperr
@@ -397,6 +415,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (2 << 16) | 15:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (11 << 16) | 0:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (3 << 16) | 0:
@@ -605,6 +633,14 @@
         return OFPERR_OFPBFC_TIMEOUT;
     case (17 << 16) | 15:
         return OFPERR_OFPBFC_BUNDLE_IN_PROGRESS;
+    case (200 << 16) | 0:
+        return OFPERR_OFPMMC_MONITOR_EXISTS;
+    case (200 << 16) | 1:
+        return OFPERR_OFPMMC_BAD_COMMAND;
+    case (200 << 16) | 2:
+        return OFPERR_OFPMMC_OVERLAP;
+    case (200 << 16) | 3:
+        return OFPERR_OFPMMC_TABLE_FULL;
     }
 
     return 0;
@@ -656,6 +692,11 @@
         {      0x0,  2,  13 }, /* OFPBAC_BAD_SET_TYPE */
         {      0x0,  2,  14 }, /* OFPBAC_BAD_SET_LEN */
         {      0x0,  2,  15 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320, 11,   0 }, /* NXBAC_MUST_BE_ZERO */
         {      0x0,  3,   0 }, /* OFPBIC_UNKNOWN_INST */
         {      0x0,  3,   1 }, /* OFPBIC_UNSUP_INST */
@@ -763,6 +804,10 @@
         {      0x0, 17,  13 }, /* OFPBFC_MSG_FAILED */
         {      0x0, 17,  14 }, /* OFPBFC_TIMEOUT */
         {      0x0, 17,  15 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {      0x0, 200,   0 }, /* OFPMMC_MONITOR_EXISTS */
+        {      0x0, 200,   1 }, /* OFPMMC_BAD_COMMAND */
+        {      0x0, 200,   2 }, /* OFPMMC_OVERLAP */
+        {      0x0, 200,   3 }, /* OFPMMC_TABLE_FULL */
     },
 };
 
@@ -852,6 +897,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (2 << 16) | 15:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (11 << 16) | 0:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (3 << 16) | 0:
@@ -1060,6 +1115,14 @@
         return OFPERR_OFPBFC_TIMEOUT;
     case (17 << 16) | 15:
         return OFPERR_OFPBFC_BUNDLE_IN_PROGRESS;
+    case (200 << 16) | 0:
+        return OFPERR_OFPMMC_MONITOR_EXISTS;
+    case (200 << 16) | 1:
+        return OFPERR_OFPMMC_BAD_COMMAND;
+    case (200 << 16) | 2:
+        return OFPERR_OFPMMC_OVERLAP;
+    case (200 << 16) | 3:
+        return OFPERR_OFPMMC_TABLE_FULL;
     }
 
     return 0;
@@ -1111,6 +1174,11 @@
         {      0x0,  2,  13 }, /* OFPBAC_BAD_SET_TYPE */
         {      0x0,  2,  14 }, /* OFPBAC_BAD_SET_LEN */
         {      0x0,  2,  15 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320, 11,   0 }, /* NXBAC_MUST_BE_ZERO */
         {      0x0,  3,   0 }, /* OFPBIC_UNKNOWN_INST */
         {      0x0,  3,   1 }, /* OFPBIC_UNSUP_INST */
@@ -1218,6 +1286,10 @@
         {      0x0, 17,  13 }, /* OFPBFC_MSG_FAILED */
         {      0x0, 17,  14 }, /* OFPBFC_TIMEOUT */
         {      0x0, 17,  15 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {      0x0, 200,   0 }, /* OFPMMC_MONITOR_EXISTS */
+        {      0x0, 200,   1 }, /* OFPMMC_BAD_COMMAND */
+        {      0x0, 200,   2 }, /* OFPMMC_OVERLAP */
+        {      0x0, 200,   3 }, /* OFPMMC_TABLE_FULL */
     },
 };
 
@@ -1295,6 +1367,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (0x2320ULL << 32) | (1 << 16) | 525:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (2 << 16) | 256:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (0x2320ULL << 32) | (0 << 16) | 263:
@@ -1388,6 +1470,11 @@
         {   0x2320,  1, 523 }, /* OFPBAC_BAD_SET_TYPE */
         {   0x2320,  1, 524 }, /* OFPBAC_BAD_SET_LEN */
         {   0x2320,  1, 525 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320,  2, 256 }, /* NXBAC_MUST_BE_ZERO */
         {       -1, -1,  -1 }, /* OFPBIC_UNKNOWN_INST */
         {       -1, -1,  -1 }, /* OFPBIC_UNSUP_INST */
@@ -1495,6 +1582,10 @@
         {       -1, -1,  -1 }, /* OFPBFC_MSG_FAILED */
         {       -1, -1,  -1 }, /* OFPBFC_TIMEOUT */
         {       -1, -1,  -1 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {       -1, -1,  -1 }, /* OFPMMC_MONITOR_EXISTS */
+        {       -1, -1,  -1 }, /* OFPMMC_BAD_COMMAND */
+        {       -1, -1,  -1 }, /* OFPMMC_OVERLAP */
+        {       -1, -1,  -1 }, /* OFPMMC_TABLE_FULL */
     },
 };
 
@@ -1578,6 +1669,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (0x2320ULL << 32) | (1 << 16) | 525:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (2 << 16) | 256:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (3 << 16) | 0:
@@ -1676,6 +1777,14 @@
         return OFPERR_OFPSCFC_BAD_LEN;
     case (0x2320ULL << 32) | (1 << 16) | 513:
         return OFPERR_OFPRRFC_BAD_ROLE;
+    case (200 << 16) | 0:
+        return OFPERR_OFPMMC_MONITOR_EXISTS;
+    case (200 << 16) | 1:
+        return OFPERR_OFPMMC_BAD_COMMAND;
+    case (200 << 16) | 2:
+        return OFPERR_OFPMMC_OVERLAP;
+    case (200 << 16) | 3:
+        return OFPERR_OFPMMC_TABLE_FULL;
     }
 
     return 0;
@@ -1727,6 +1836,11 @@
         {   0x2320,  1, 523 }, /* OFPBAC_BAD_SET_TYPE */
         {   0x2320,  1, 524 }, /* OFPBAC_BAD_SET_LEN */
         {   0x2320,  1, 525 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320,  2, 256 }, /* NXBAC_MUST_BE_ZERO */
         {      0x0,  3,   0 }, /* OFPBIC_UNKNOWN_INST */
         {      0x0,  3,   1 }, /* OFPBIC_UNSUP_INST */
@@ -1834,6 +1948,10 @@
         {       -1, -1,  -1 }, /* OFPBFC_MSG_FAILED */
         {       -1, -1,  -1 }, /* OFPBFC_TIMEOUT */
         {       -1, -1,  -1 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {      0x0, 200,   0 }, /* OFPMMC_MONITOR_EXISTS */
+        {      0x0, 200,   1 }, /* OFPMMC_BAD_COMMAND */
+        {      0x0, 200,   2 }, /* OFPMMC_OVERLAP */
+        {      0x0, 200,   3 }, /* OFPMMC_TABLE_FULL */
     },
 };
 
@@ -1921,6 +2039,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (2 << 16) | 15:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (11 << 16) | 0:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (3 << 16) | 0:
@@ -2049,6 +2177,14 @@
         return OFPERR_OFPRRFC_UNSUP;
     case (11 << 16) | 2:
         return OFPERR_OFPRRFC_BAD_ROLE;
+    case (200 << 16) | 0:
+        return OFPERR_OFPMMC_MONITOR_EXISTS;
+    case (200 << 16) | 1:
+        return OFPERR_OFPMMC_BAD_COMMAND;
+    case (200 << 16) | 2:
+        return OFPERR_OFPMMC_OVERLAP;
+    case (200 << 16) | 3:
+        return OFPERR_OFPMMC_TABLE_FULL;
     }
 
     return 0;
@@ -2100,6 +2236,11 @@
         {      0x0,  2,  13 }, /* OFPBAC_BAD_SET_TYPE */
         {      0x0,  2,  14 }, /* OFPBAC_BAD_SET_LEN */
         {      0x0,  2,  15 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320, 11,   0 }, /* NXBAC_MUST_BE_ZERO */
         {      0x0,  3,   0 }, /* OFPBIC_UNKNOWN_INST */
         {      0x0,  3,   1 }, /* OFPBIC_UNSUP_INST */
@@ -2207,6 +2348,10 @@
         {       -1, -1,  -1 }, /* OFPBFC_MSG_FAILED */
         {       -1, -1,  -1 }, /* OFPBFC_TIMEOUT */
         {       -1, -1,  -1 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {      0x0, 200,   0 }, /* OFPMMC_MONITOR_EXISTS */
+        {      0x0, 200,   1 }, /* OFPMMC_BAD_COMMAND */
+        {      0x0, 200,   2 }, /* OFPMMC_OVERLAP */
+        {      0x0, 200,   3 }, /* OFPMMC_TABLE_FULL */
     },
 };
 
@@ -2296,6 +2441,16 @@
         return OFPERR_OFPBAC_BAD_SET_LEN;
     case (2 << 16) | 15:
         return OFPERR_OFPBAC_BAD_SET_ARGUMENT;
+    case (2 << 16) | 200:
+        return OFPERR_OFPBAC_BAD_MONITOR_TYPE;
+    case (2 << 16) | 201:
+        return OFPERR_OFPBAC_BAD_MONITOR_LEN;
+    case (2 << 16) | 202:
+        return OFPERR_OFPBAC_BAD_MONITOR_ARGUMENT;
+    case (2 << 16) | 250:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_SWITCH;
+    case (2 << 16) | 251:
+        return OFPERR_OFPBAC_BAD_PRTSCAN_INTERVAL;
     case (0x2320ULL << 32) | (11 << 16) | 0:
         return OFPERR_NXBAC_MUST_BE_ZERO;
     case (3 << 16) | 0:
@@ -2460,6 +2615,14 @@
         return OFPERR_OFPBPC_BAD_LEN;
     case (13 << 16) | 4:
         return OFPERR_OFPBPC_BAD_VALUE;
+    case (200 << 16) | 0:
+        return OFPERR_OFPMMC_MONITOR_EXISTS;
+    case (200 << 16) | 1:
+        return OFPERR_OFPMMC_BAD_COMMAND;
+    case (200 << 16) | 2:
+        return OFPERR_OFPMMC_OVERLAP;
+    case (200 << 16) | 3:
+        return OFPERR_OFPMMC_TABLE_FULL;
     }
 
     return 0;
@@ -2511,6 +2674,11 @@
         {      0x0,  2,  13 }, /* OFPBAC_BAD_SET_TYPE */
         {      0x0,  2,  14 }, /* OFPBAC_BAD_SET_LEN */
         {      0x0,  2,  15 }, /* OFPBAC_BAD_SET_ARGUMENT */
+        {      0x0,  2, 200 }, /* OFPBAC_BAD_MONITOR_TYPE */
+        {      0x0,  2, 201 }, /* OFPBAC_BAD_MONITOR_LEN */
+        {      0x0,  2, 202 }, /* OFPBAC_BAD_MONITOR_ARGUMENT */
+        {      0x0,  2, 250 }, /* OFPBAC_BAD_PRTSCAN_SWITCH */
+        {      0x0,  2, 251 }, /* OFPBAC_BAD_PRTSCAN_INTERVAL */
         {   0x2320, 11,   0 }, /* NXBAC_MUST_BE_ZERO */
         {      0x0,  3,   0 }, /* OFPBIC_UNKNOWN_INST */
         {      0x0,  3,   1 }, /* OFPBIC_UNSUP_INST */
@@ -2618,5 +2786,9 @@
         {       -1, -1,  -1 }, /* OFPBFC_MSG_FAILED */
         {       -1, -1,  -1 }, /* OFPBFC_TIMEOUT */
         {       -1, -1,  -1 }, /* OFPBFC_BUNDLE_IN_PROGRESS */
+        {      0x0, 200,   0 }, /* OFPMMC_MONITOR_EXISTS */
+        {      0x0, 200,   1 }, /* OFPMMC_BAD_COMMAND */
+        {      0x0, 200,   2 }, /* OFPMMC_OVERLAP */
+        {      0x0, 200,   3 }, /* OFPMMC_TABLE_FULL */
     },
 };
diff -Naur openvswitch-2.3.2/lib/ofp-msgs.h umon_ovs2.3/lib/ofp-msgs.h
--- openvswitch-2.3.2/lib/ofp-msgs.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-msgs.h	2016-06-23 10:09:00.757747208 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFP_MSGS_H
 #define OFP_MSGS_H 1
 
@@ -245,6 +264,12 @@
     /* OFPT 1.4+ (34): struct ofp14_bundle_ctrl_msg, uint8_t[]. */
     OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE,
 
+    /* OFPT 1.0+ (200): struct ofp11_monitor_mod, uint8_t[8][]. */
+    OFPRAW_OFPT11_MONITOR_MOD,
+
+    /* OFPT 1.0+ (201): struct ofp11_prtscan_alert, uint8_t[8][]. */
+    OFPRAW_OFPT11_PRTSCAN_ALERT,
+
 /* Standard statistics. */
 
     /* OFPST 1.0+ (0): void. */
@@ -379,6 +404,11 @@
     /* OFPST 1.4+ (13): uint8_t[8][]. */
     OFPRAW_OFPST14_PORT_DESC_REPLY,
 
+    /* OFPST 1.0+ (200): struct ofp11_monitor_stats_request, uint8_t[8][]. */
+    OFPRAW_OFPST11_MONITOR_STAT_REQUEST,
+    /* OFPST 1.0+ (200): struct ofp11_monitor_stats[].  */
+    OFPRAW_OFPST11_MONITOR_STAT_REPLY,
+
 /* Nicira extension messages.
  *
  * Nicira extensions that correspond to standard OpenFlow messages are listed
@@ -537,6 +567,9 @@
 
     OFPTYPE_BUNDLE_ADD_MESSAGE,   /* OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE. */
 
+    OFPTYPE_MONITOR_MOD,         /* OFPRAW_OFPT11_MONITOR_MOD. */
+    OFPTYPE_PRTSCAN_ALERT,	 /* OFPRAW_OFPT11_PRTSCAN_ALERT. */
+
     /* Statistics. */
     OFPTYPE_DESC_STATS_REQUEST,      /* OFPRAW_OFPST_DESC_REQUEST. */
     OFPTYPE_DESC_STATS_REPLY,        /* OFPRAW_OFPST_DESC_REPLY. */
@@ -606,6 +639,8 @@
     OFPTYPE_PORT_DESC_STATS_REPLY,   /* OFPRAW_OFPST10_PORT_DESC_REPLY.
                                       * OFPRAW_OFPST11_PORT_DESC_REPLY.
                                       * OFPRAW_OFPST14_PORT_DESC_REPLY. */
+    OFPTYPE_MONITOR_STATS_REQUEST,   /* OFPRAW_OFPST11_MONITOR_STAT_REQUEST. */
+    OFPTYPE_MONITOR_STATS_REPLY,     /* OFPRAW_OFPST11_MONITOR_STAT_REPLY. */
 
     /* Nicira extensions. */
     OFPTYPE_SET_FLOW_FORMAT,      /* OFPRAW_NXT_SET_FLOW_FORMAT. */
diff -Naur openvswitch-2.3.2/lib/ofp-msgs.inc umon_ovs2.3/lib/ofp-msgs.inc
--- openvswitch-2.3.2/lib/ofp-msgs.inc	2015-06-18 15:33:03.000000000 -0400
+++ umon_ovs2.3/lib/ofp-msgs.inc	2015-10-26 21:27:43.000000000 -0400
@@ -1286,6 +1286,14 @@
     { {0, NULL}, {5, 34, 0, 0x0, 0}, OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE, 0 },
     { {0, NULL}, {6, 34, 0, 0x0, 0}, OFPRAW_OFPT14_BUNDLE_ADD_MESSAGE, 0 },
 };
+static struct raw_instance ofpraw_ofpt11_monitor_mod_instances[] = {
+    { {0, NULL}, {1, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+    { {0, NULL}, {2, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+    { {0, NULL}, {3, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+    { {0, NULL}, {4, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+    { {0, NULL}, {5, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+    { {0, NULL}, {6, 200, 0, 0x0, 0}, OFPRAW_OFPT11_MONITOR_MOD, 0 },
+};
 static struct raw_instance ofpraw_ofpst_desc_request_instances[] = {
     { {0, NULL}, {1, 16, 0, 0x0, 0}, OFPRAW_OFPST_DESC_REQUEST, 0 },
     { {0, NULL}, {2, 18, 0, 0x0, 0}, OFPRAW_OFPST_DESC_REQUEST, 0 },
@@ -1530,6 +1538,22 @@
     { {0, NULL}, {5, 19, 13, 0x0, 0}, OFPRAW_OFPST14_PORT_DESC_REPLY, 0 },
     { {0, NULL}, {6, 19, 13, 0x0, 0}, OFPRAW_OFPST14_PORT_DESC_REPLY, 0 },
 };
+static struct raw_instance ofpraw_ofpst11_monitor_stat_request_instances[] = {
+    { {0, NULL}, {1, 16, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+    { {0, NULL}, {2, 18, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+    { {0, NULL}, {3, 18, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+    { {0, NULL}, {4, 18, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+    { {0, NULL}, {5, 18, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+    { {0, NULL}, {6, 18, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REQUEST, 0 },
+};
+static struct raw_instance ofpraw_ofpst11_monitor_stat_reply_instances[] = {
+    { {0, NULL}, {1, 17, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+    { {0, NULL}, {2, 19, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+    { {0, NULL}, {3, 19, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+    { {0, NULL}, {4, 19, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+    { {0, NULL}, {5, 19, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+    { {0, NULL}, {6, 19, 200, 0x0, 0}, OFPRAW_OFPST11_MONITOR_STAT_REPLY, 0 },
+};
 static struct raw_instance ofpraw_nxt_set_flow_format_instances[] = {
     { {0, NULL}, {1, 4, 0, 0x2320, 12}, OFPRAW_NXT_SET_FLOW_FORMAT, 0 },
 };
@@ -1604,7 +1628,7 @@
         0,
 #line 109 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1608 "lib/ofp-msgs.inc"
+#line 1632 "lib/ofp-msgs.inc"
         OFPTYPE_HELLO,
         "OFPT_HELLO",
     },
@@ -1615,7 +1639,7 @@
         sizeof(struct ofp_error_msg),
 #line 112 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1619 "lib/ofp-msgs.inc"
+#line 1643 "lib/ofp-msgs.inc"
         OFPTYPE_ERROR,
         "OFPT_ERROR",
     },
@@ -1626,7 +1650,7 @@
         0,
 #line 115 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1630 "lib/ofp-msgs.inc"
+#line 1654 "lib/ofp-msgs.inc"
         OFPTYPE_ECHO_REQUEST,
         "OFPT_ECHO_REQUEST",
     },
@@ -1637,7 +1661,7 @@
         0,
 #line 118 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1641 "lib/ofp-msgs.inc"
+#line 1665 "lib/ofp-msgs.inc"
         OFPTYPE_ECHO_REPLY,
         "OFPT_ECHO_REPLY",
     },
@@ -1648,7 +1672,7 @@
         0,
 #line 126 "./lib/ofp-msgs.h"
         0,
-#line 1652 "lib/ofp-msgs.inc"
+#line 1676 "lib/ofp-msgs.inc"
         OFPTYPE_FEATURES_REQUEST,
         "OFPT_FEATURES_REQUEST",
     },
@@ -1659,7 +1683,7 @@
         sizeof(struct ofp_switch_features),
 #line 129 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_phy_port),
-#line 1663 "lib/ofp-msgs.inc"
+#line 1687 "lib/ofp-msgs.inc"
         OFPTYPE_FEATURES_REPLY,
         "OFPT_FEATURES_REPLY",
     },
@@ -1670,7 +1694,7 @@
         sizeof(struct ofp_switch_features),
 #line 131 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_port),
-#line 1674 "lib/ofp-msgs.inc"
+#line 1698 "lib/ofp-msgs.inc"
         OFPTYPE_FEATURES_REPLY,
         "OFPT_FEATURES_REPLY",
     },
@@ -1681,7 +1705,7 @@
         sizeof(struct ofp_switch_features),
 #line 133 "./lib/ofp-msgs.h"
         0,
-#line 1685 "lib/ofp-msgs.inc"
+#line 1709 "lib/ofp-msgs.inc"
         OFPTYPE_FEATURES_REPLY,
         "OFPT_FEATURES_REPLY",
     },
@@ -1692,7 +1716,7 @@
         0,
 #line 136 "./lib/ofp-msgs.h"
         0,
-#line 1696 "lib/ofp-msgs.inc"
+#line 1720 "lib/ofp-msgs.inc"
         OFPTYPE_GET_CONFIG_REQUEST,
         "OFPT_GET_CONFIG_REQUEST",
     },
@@ -1703,7 +1727,7 @@
         sizeof(struct ofp_switch_config),
 #line 139 "./lib/ofp-msgs.h"
         0,
-#line 1707 "lib/ofp-msgs.inc"
+#line 1731 "lib/ofp-msgs.inc"
         OFPTYPE_GET_CONFIG_REPLY,
         "OFPT_GET_CONFIG_REPLY",
     },
@@ -1714,7 +1738,7 @@
         sizeof(struct ofp_switch_config),
 #line 142 "./lib/ofp-msgs.h"
         0,
-#line 1718 "lib/ofp-msgs.inc"
+#line 1742 "lib/ofp-msgs.inc"
         OFPTYPE_SET_CONFIG,
         "OFPT_SET_CONFIG",
     },
@@ -1725,7 +1749,7 @@
         offsetof(struct ofp10_packet_in, data),
 #line 145 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1729 "lib/ofp-msgs.inc"
+#line 1753 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_IN,
         "OFPT_PACKET_IN",
     },
@@ -1736,7 +1760,7 @@
         sizeof(struct ofp11_packet_in),
 #line 147 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1740 "lib/ofp-msgs.inc"
+#line 1764 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_IN,
         "OFPT_PACKET_IN",
     },
@@ -1747,7 +1771,7 @@
         sizeof(struct ofp12_packet_in),
 #line 149 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1751 "lib/ofp-msgs.inc"
+#line 1775 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_IN,
         "OFPT_PACKET_IN",
     },
@@ -1758,7 +1782,7 @@
         sizeof(struct ofp13_packet_in),
 #line 151 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1762 "lib/ofp-msgs.inc"
+#line 1786 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_IN,
         "OFPT_PACKET_IN",
     },
@@ -1769,7 +1793,7 @@
         sizeof(struct nx_packet_in),
 #line 153 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1773 "lib/ofp-msgs.inc"
+#line 1797 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_IN,
         "NXT_PACKET_IN",
     },
@@ -1780,7 +1804,7 @@
         sizeof(struct ofp10_flow_removed),
 #line 156 "./lib/ofp-msgs.h"
         0,
-#line 1784 "lib/ofp-msgs.inc"
+#line 1808 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_REMOVED,
         "OFPT_FLOW_REMOVED",
     },
@@ -1791,7 +1815,7 @@
         sizeof(struct ofp11_flow_removed),
 #line 158 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1795 "lib/ofp-msgs.inc"
+#line 1819 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_REMOVED,
         "OFPT_FLOW_REMOVED",
     },
@@ -1802,7 +1826,7 @@
         sizeof(struct nx_flow_removed),
 #line 160 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1806 "lib/ofp-msgs.inc"
+#line 1830 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_REMOVED,
         "NXT_FLOW_REMOVED",
     },
@@ -1813,7 +1837,7 @@
         sizeof(struct ofp_port_status) + sizeof(struct ofp10_phy_port),
 #line 163 "./lib/ofp-msgs.h"
         0,
-#line 1817 "lib/ofp-msgs.inc"
+#line 1841 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATUS,
         "OFPT_PORT_STATUS",
     },
@@ -1824,7 +1848,7 @@
         sizeof(struct ofp_port_status) + sizeof(struct ofp11_port),
 #line 165 "./lib/ofp-msgs.h"
         0,
-#line 1828 "lib/ofp-msgs.inc"
+#line 1852 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATUS,
         "OFPT_PORT_STATUS",
     },
@@ -1835,7 +1859,7 @@
         sizeof(struct ofp_port_status) + sizeof(struct ofp14_port),
 #line 167 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1839 "lib/ofp-msgs.inc"
+#line 1863 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATUS,
         "OFPT_PORT_STATUS",
     },
@@ -1846,7 +1870,7 @@
         sizeof(struct ofp10_packet_out),
 #line 170 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1850 "lib/ofp-msgs.inc"
+#line 1874 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_OUT,
         "OFPT_PACKET_OUT",
     },
@@ -1857,7 +1881,7 @@
         sizeof(struct ofp11_packet_out),
 #line 172 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 1861 "lib/ofp-msgs.inc"
+#line 1885 "lib/ofp-msgs.inc"
         OFPTYPE_PACKET_OUT,
         "OFPT_PACKET_OUT",
     },
@@ -1868,7 +1892,7 @@
         sizeof(struct ofp10_flow_mod),
 #line 175 "./lib/ofp-msgs.h"
         sizeof(struct ofp_action_header),
-#line 1872 "lib/ofp-msgs.inc"
+#line 1896 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MOD,
         "OFPT_FLOW_MOD",
     },
@@ -1879,7 +1903,7 @@
         sizeof(struct ofp11_flow_mod),
 #line 177 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_instruction),
-#line 1883 "lib/ofp-msgs.inc"
+#line 1907 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MOD,
         "OFPT_FLOW_MOD",
     },
@@ -1890,7 +1914,7 @@
         sizeof(struct nx_flow_mod),
 #line 179 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1894 "lib/ofp-msgs.inc"
+#line 1918 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MOD,
         "NXT_FLOW_MOD",
     },
@@ -1901,7 +1925,7 @@
         sizeof(struct ofp11_group_mod),
 #line 182 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1905 "lib/ofp-msgs.inc"
+#line 1929 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_MOD,
         "OFPT_GROUP_MOD",
     },
@@ -1912,7 +1936,7 @@
         sizeof(struct ofp10_port_mod),
 #line 185 "./lib/ofp-msgs.h"
         0,
-#line 1916 "lib/ofp-msgs.inc"
+#line 1940 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_MOD,
         "OFPT_PORT_MOD",
     },
@@ -1923,7 +1947,7 @@
         sizeof(struct ofp11_port_mod),
 #line 187 "./lib/ofp-msgs.h"
         0,
-#line 1927 "lib/ofp-msgs.inc"
+#line 1951 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_MOD,
         "OFPT_PORT_MOD",
     },
@@ -1934,7 +1958,7 @@
         sizeof(struct ofp14_port_mod),
 #line 189 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1938 "lib/ofp-msgs.inc"
+#line 1962 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_MOD,
         "OFPT_PORT_MOD",
     },
@@ -1945,7 +1969,7 @@
         sizeof(struct ofp11_table_mod),
 #line 192 "./lib/ofp-msgs.h"
         0,
-#line 1949 "lib/ofp-msgs.inc"
+#line 1973 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_MOD,
         "OFPT_TABLE_MOD",
     },
@@ -1956,7 +1980,7 @@
         sizeof(struct ofp14_table_mod),
 #line 194 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 1960 "lib/ofp-msgs.inc"
+#line 1984 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_MOD,
         "OFPT_TABLE_MOD",
     },
@@ -1967,7 +1991,7 @@
         0,
 #line 197 "./lib/ofp-msgs.h"
         0,
-#line 1971 "lib/ofp-msgs.inc"
+#line 1995 "lib/ofp-msgs.inc"
         OFPTYPE_BARRIER_REQUEST,
         "OFPT_BARRIER_REQUEST",
     },
@@ -1978,7 +2002,7 @@
         0,
 #line 199 "./lib/ofp-msgs.h"
         0,
-#line 1982 "lib/ofp-msgs.inc"
+#line 2006 "lib/ofp-msgs.inc"
         OFPTYPE_BARRIER_REQUEST,
         "OFPT_BARRIER_REQUEST",
     },
@@ -1989,7 +2013,7 @@
         0,
 #line 202 "./lib/ofp-msgs.h"
         0,
-#line 1993 "lib/ofp-msgs.inc"
+#line 2017 "lib/ofp-msgs.inc"
         OFPTYPE_BARRIER_REPLY,
         "OFPT_BARRIER_REPLY",
     },
@@ -2000,7 +2024,7 @@
         0,
 #line 204 "./lib/ofp-msgs.h"
         0,
-#line 2004 "lib/ofp-msgs.inc"
+#line 2028 "lib/ofp-msgs.inc"
         OFPTYPE_BARRIER_REPLY,
         "OFPT_BARRIER_REPLY",
     },
@@ -2011,7 +2035,7 @@
         sizeof(struct ofp10_queue_get_config_request),
 #line 207 "./lib/ofp-msgs.h"
         0,
-#line 2015 "lib/ofp-msgs.inc"
+#line 2039 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_GET_CONFIG_REQUEST,
         "OFPT_QUEUE_GET_CONFIG_REQUEST",
     },
@@ -2022,7 +2046,7 @@
         sizeof(struct ofp11_queue_get_config_request),
 #line 209 "./lib/ofp-msgs.h"
         0,
-#line 2026 "lib/ofp-msgs.inc"
+#line 2050 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_GET_CONFIG_REQUEST,
         "OFPT_QUEUE_GET_CONFIG_REQUEST",
     },
@@ -2033,7 +2057,7 @@
         sizeof(struct ofp10_queue_get_config_reply),
 #line 212 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2037 "lib/ofp-msgs.inc"
+#line 2061 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_GET_CONFIG_REPLY,
         "OFPT_QUEUE_GET_CONFIG_REPLY",
     },
@@ -2044,7 +2068,7 @@
         sizeof(struct ofp11_queue_get_config_reply),
 #line 214 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2048 "lib/ofp-msgs.inc"
+#line 2072 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_GET_CONFIG_REPLY,
         "OFPT_QUEUE_GET_CONFIG_REPLY",
     },
@@ -2055,7 +2079,7 @@
         sizeof(struct ofp12_role_request),
 #line 217 "./lib/ofp-msgs.h"
         0,
-#line 2059 "lib/ofp-msgs.inc"
+#line 2083 "lib/ofp-msgs.inc"
         OFPTYPE_ROLE_REQUEST,
         "OFPT_ROLE_REQUEST",
     },
@@ -2066,7 +2090,7 @@
         sizeof(struct nx_role_request),
 #line 219 "./lib/ofp-msgs.h"
         0,
-#line 2070 "lib/ofp-msgs.inc"
+#line 2094 "lib/ofp-msgs.inc"
         OFPTYPE_ROLE_REQUEST,
         "NXT_ROLE_REQUEST",
     },
@@ -2077,7 +2101,7 @@
         sizeof(struct ofp12_role_request),
 #line 222 "./lib/ofp-msgs.h"
         0,
-#line 2081 "lib/ofp-msgs.inc"
+#line 2105 "lib/ofp-msgs.inc"
         OFPTYPE_ROLE_REPLY,
         "OFPT_ROLE_REPLY",
     },
@@ -2088,7 +2112,7 @@
         sizeof(struct nx_role_request),
 #line 224 "./lib/ofp-msgs.h"
         0,
-#line 2092 "lib/ofp-msgs.inc"
+#line 2116 "lib/ofp-msgs.inc"
         OFPTYPE_ROLE_REPLY,
         "NXT_ROLE_REPLY",
     },
@@ -2099,7 +2123,7 @@
         0,
 #line 227 "./lib/ofp-msgs.h"
         0,
-#line 2103 "lib/ofp-msgs.inc"
+#line 2127 "lib/ofp-msgs.inc"
         OFPTYPE_GET_ASYNC_REQUEST,
         "OFPT_GET_ASYNC_REQUEST",
     },
@@ -2110,7 +2134,7 @@
         sizeof(struct ofp13_async_config),
 #line 229 "./lib/ofp-msgs.h"
         0,
-#line 2114 "lib/ofp-msgs.inc"
+#line 2138 "lib/ofp-msgs.inc"
         OFPTYPE_GET_ASYNC_REPLY,
         "OFPT_GET_ASYNC_REPLY",
     },
@@ -2121,7 +2145,7 @@
         sizeof(struct ofp13_async_config),
 #line 231 "./lib/ofp-msgs.h"
         0,
-#line 2125 "lib/ofp-msgs.inc"
+#line 2149 "lib/ofp-msgs.inc"
         OFPTYPE_SET_ASYNC_CONFIG,
         "OFPT_SET_ASYNC",
     },
@@ -2132,7 +2156,7 @@
         sizeof(struct nx_async_config),
 #line 233 "./lib/ofp-msgs.h"
         0,
-#line 2136 "lib/ofp-msgs.inc"
+#line 2160 "lib/ofp-msgs.inc"
         OFPTYPE_SET_ASYNC_CONFIG,
         "NXT_SET_ASYNC_CONFIG",
     },
@@ -2143,7 +2167,7 @@
         sizeof(struct ofp13_meter_mod),
 #line 236 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2147 "lib/ofp-msgs.inc"
+#line 2171 "lib/ofp-msgs.inc"
         OFPTYPE_METER_MOD,
         "OFPT_METER_MOD",
     },
@@ -2154,7 +2178,7 @@
         sizeof(struct ofp14_role_status),
 #line 239 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2158 "lib/ofp-msgs.inc"
+#line 2182 "lib/ofp-msgs.inc"
         OFPTYPE_ROLE_STATUS,
         "OFPT_ROLE_STATUS",
     },
@@ -2165,7 +2189,7 @@
         sizeof(struct ofp14_bundle_ctrl_msg),
 #line 242 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2169 "lib/ofp-msgs.inc"
+#line 2193 "lib/ofp-msgs.inc"
         OFPTYPE_BUNDLE_CONTROL,
         "OFPT_BUNDLE_CONTROL",
     },
@@ -2176,689 +2200,722 @@
         sizeof(struct ofp14_bundle_ctrl_msg),
 #line 245 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 2180 "lib/ofp-msgs.inc"
+#line 2204 "lib/ofp-msgs.inc"
         OFPTYPE_BUNDLE_ADD_MESSAGE,
         "OFPT_BUNDLE_ADD_MESSAGE",
     },
     {
+        ofpraw_ofpt11_monitor_mod_instances,
+        1, 6,
+#line 248 "./lib/ofp-msgs.h"
+        sizeof(struct ofp11_monitor_mod),
+#line 248 "./lib/ofp-msgs.h"
+        sizeof(uint8_t[8]),
+#line 2215 "lib/ofp-msgs.inc"
+        OFPTYPE_MONITOR_MOD,
+        "OFPT_MONITOR_MOD",
+    },
+    {
         ofpraw_ofpst_desc_request_instances,
         1, 6,
-#line 250 "./lib/ofp-msgs.h"
+#line 253 "./lib/ofp-msgs.h"
         0,
-#line 250 "./lib/ofp-msgs.h"
+#line 253 "./lib/ofp-msgs.h"
         0,
-#line 2191 "lib/ofp-msgs.inc"
+#line 2226 "lib/ofp-msgs.inc"
         OFPTYPE_DESC_STATS_REQUEST,
         "OFPST_DESC request",
     },
     {
         ofpraw_ofpst_desc_reply_instances,
         1, 6,
-#line 253 "./lib/ofp-msgs.h"
+#line 256 "./lib/ofp-msgs.h"
         sizeof(struct ofp_desc_stats),
-#line 253 "./lib/ofp-msgs.h"
+#line 256 "./lib/ofp-msgs.h"
         0,
-#line 2202 "lib/ofp-msgs.inc"
+#line 2237 "lib/ofp-msgs.inc"
         OFPTYPE_DESC_STATS_REPLY,
         "OFPST_DESC reply",
     },
     {
         ofpraw_ofpst10_flow_request_instances,
         1, 1,
-#line 256 "./lib/ofp-msgs.h"
+#line 259 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_flow_stats_request),
-#line 256 "./lib/ofp-msgs.h"
+#line 259 "./lib/ofp-msgs.h"
         0,
-#line 2213 "lib/ofp-msgs.inc"
+#line 2248 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REQUEST,
         "OFPST_FLOW request",
     },
     {
         ofpraw_ofpst11_flow_request_instances,
         2, 6,
-#line 258 "./lib/ofp-msgs.h"
+#line 261 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_flow_stats_request),
-#line 258 "./lib/ofp-msgs.h"
+#line 261 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2224 "lib/ofp-msgs.inc"
+#line 2259 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REQUEST,
         "OFPST_FLOW request",
     },
     {
         ofpraw_nxst_flow_request_instances,
         1, 1,
-#line 260 "./lib/ofp-msgs.h"
+#line 263 "./lib/ofp-msgs.h"
         sizeof(struct nx_flow_stats_request),
-#line 260 "./lib/ofp-msgs.h"
+#line 263 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2235 "lib/ofp-msgs.inc"
+#line 2270 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REQUEST,
         "NXST_FLOW request",
     },
     {
         ofpraw_ofpst10_flow_reply_instances,
         1, 1,
-#line 263 "./lib/ofp-msgs.h"
+#line 266 "./lib/ofp-msgs.h"
         0,
-#line 263 "./lib/ofp-msgs.h"
+#line 266 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 2246 "lib/ofp-msgs.inc"
+#line 2281 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REPLY,
         "OFPST_FLOW reply",
     },
     {
         ofpraw_ofpst11_flow_reply_instances,
         2, 3,
-#line 265 "./lib/ofp-msgs.h"
+#line 268 "./lib/ofp-msgs.h"
         0,
-#line 265 "./lib/ofp-msgs.h"
+#line 268 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 2257 "lib/ofp-msgs.inc"
+#line 2292 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REPLY,
         "OFPST_FLOW reply",
     },
     {
         ofpraw_ofpst13_flow_reply_instances,
         4, 6,
-#line 267 "./lib/ofp-msgs.h"
+#line 270 "./lib/ofp-msgs.h"
         0,
-#line 267 "./lib/ofp-msgs.h"
+#line 270 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 2268 "lib/ofp-msgs.inc"
+#line 2303 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REPLY,
         "OFPST_FLOW reply",
     },
     {
         ofpraw_nxst_flow_reply_instances,
         1, 1,
-#line 269 "./lib/ofp-msgs.h"
+#line 272 "./lib/ofp-msgs.h"
         0,
-#line 269 "./lib/ofp-msgs.h"
+#line 272 "./lib/ofp-msgs.h"
         sizeof(uint8_t),
-#line 2279 "lib/ofp-msgs.inc"
+#line 2314 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_STATS_REPLY,
         "NXST_FLOW reply",
     },
     {
         ofpraw_ofpst10_aggregate_request_instances,
         1, 1,
-#line 272 "./lib/ofp-msgs.h"
+#line 275 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_flow_stats_request),
-#line 272 "./lib/ofp-msgs.h"
+#line 275 "./lib/ofp-msgs.h"
         0,
-#line 2290 "lib/ofp-msgs.inc"
+#line 2325 "lib/ofp-msgs.inc"
         OFPTYPE_AGGREGATE_STATS_REQUEST,
         "OFPST_AGGREGATE request",
     },
     {
         ofpraw_ofpst11_aggregate_request_instances,
         2, 6,
-#line 274 "./lib/ofp-msgs.h"
+#line 277 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_flow_stats_request),
-#line 274 "./lib/ofp-msgs.h"
+#line 277 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2301 "lib/ofp-msgs.inc"
+#line 2336 "lib/ofp-msgs.inc"
         OFPTYPE_AGGREGATE_STATS_REQUEST,
         "OFPST_AGGREGATE request",
     },
     {
         ofpraw_nxst_aggregate_request_instances,
         1, 1,
-#line 276 "./lib/ofp-msgs.h"
+#line 279 "./lib/ofp-msgs.h"
         sizeof(struct nx_flow_stats_request),
-#line 276 "./lib/ofp-msgs.h"
+#line 279 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2312 "lib/ofp-msgs.inc"
+#line 2347 "lib/ofp-msgs.inc"
         OFPTYPE_AGGREGATE_STATS_REQUEST,
         "NXST_AGGREGATE request",
     },
     {
         ofpraw_ofpst_aggregate_reply_instances,
         1, 6,
-#line 279 "./lib/ofp-msgs.h"
+#line 282 "./lib/ofp-msgs.h"
         sizeof(struct ofp_aggregate_stats_reply),
-#line 279 "./lib/ofp-msgs.h"
+#line 282 "./lib/ofp-msgs.h"
         0,
-#line 2323 "lib/ofp-msgs.inc"
+#line 2358 "lib/ofp-msgs.inc"
         OFPTYPE_AGGREGATE_STATS_REPLY,
         "OFPST_AGGREGATE reply",
     },
     {
         ofpraw_nxst_aggregate_reply_instances,
         1, 1,
-#line 281 "./lib/ofp-msgs.h"
+#line 284 "./lib/ofp-msgs.h"
         sizeof(struct ofp_aggregate_stats_reply),
-#line 281 "./lib/ofp-msgs.h"
+#line 284 "./lib/ofp-msgs.h"
         0,
-#line 2334 "lib/ofp-msgs.inc"
+#line 2369 "lib/ofp-msgs.inc"
         OFPTYPE_AGGREGATE_STATS_REPLY,
         "NXST_AGGREGATE reply",
     },
     {
         ofpraw_ofpst_table_request_instances,
         1, 6,
-#line 284 "./lib/ofp-msgs.h"
+#line 287 "./lib/ofp-msgs.h"
         0,
-#line 284 "./lib/ofp-msgs.h"
+#line 287 "./lib/ofp-msgs.h"
         0,
-#line 2345 "lib/ofp-msgs.inc"
+#line 2380 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_STATS_REQUEST,
         "OFPST_TABLE request",
     },
     {
         ofpraw_ofpst10_table_reply_instances,
         1, 1,
-#line 287 "./lib/ofp-msgs.h"
+#line 290 "./lib/ofp-msgs.h"
         0,
-#line 287 "./lib/ofp-msgs.h"
+#line 290 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_table_stats),
-#line 2356 "lib/ofp-msgs.inc"
+#line 2391 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_STATS_REPLY,
         "OFPST_TABLE reply",
     },
     {
         ofpraw_ofpst11_table_reply_instances,
         2, 2,
-#line 289 "./lib/ofp-msgs.h"
+#line 292 "./lib/ofp-msgs.h"
         0,
-#line 289 "./lib/ofp-msgs.h"
+#line 292 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_table_stats),
-#line 2367 "lib/ofp-msgs.inc"
+#line 2402 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_STATS_REPLY,
         "OFPST_TABLE reply",
     },
     {
         ofpraw_ofpst12_table_reply_instances,
         3, 3,
-#line 291 "./lib/ofp-msgs.h"
+#line 294 "./lib/ofp-msgs.h"
         0,
-#line 291 "./lib/ofp-msgs.h"
+#line 294 "./lib/ofp-msgs.h"
         sizeof(struct ofp12_table_stats),
-#line 2378 "lib/ofp-msgs.inc"
+#line 2413 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_STATS_REPLY,
         "OFPST_TABLE reply",
     },
     {
         ofpraw_ofpst13_table_reply_instances,
         4, 6,
-#line 293 "./lib/ofp-msgs.h"
+#line 296 "./lib/ofp-msgs.h"
         0,
-#line 293 "./lib/ofp-msgs.h"
+#line 296 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_table_stats),
-#line 2389 "lib/ofp-msgs.inc"
+#line 2424 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_STATS_REPLY,
         "OFPST_TABLE reply",
     },
     {
         ofpraw_ofpst10_port_request_instances,
         1, 1,
-#line 296 "./lib/ofp-msgs.h"
+#line 299 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_port_stats_request),
-#line 296 "./lib/ofp-msgs.h"
+#line 299 "./lib/ofp-msgs.h"
         0,
-#line 2400 "lib/ofp-msgs.inc"
+#line 2435 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REQUEST,
         "OFPST_PORT request",
     },
     {
         ofpraw_ofpst11_port_request_instances,
         2, 6,
-#line 298 "./lib/ofp-msgs.h"
+#line 301 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_port_stats_request),
-#line 298 "./lib/ofp-msgs.h"
+#line 301 "./lib/ofp-msgs.h"
         0,
-#line 2411 "lib/ofp-msgs.inc"
+#line 2446 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REQUEST,
         "OFPST_PORT request",
     },
     {
         ofpraw_ofpst10_port_reply_instances,
         1, 1,
-#line 301 "./lib/ofp-msgs.h"
+#line 304 "./lib/ofp-msgs.h"
         0,
-#line 301 "./lib/ofp-msgs.h"
+#line 304 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_port_stats),
-#line 2422 "lib/ofp-msgs.inc"
+#line 2457 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REPLY,
         "OFPST_PORT reply",
     },
     {
         ofpraw_ofpst11_port_reply_instances,
         2, 3,
-#line 303 "./lib/ofp-msgs.h"
+#line 306 "./lib/ofp-msgs.h"
         0,
-#line 303 "./lib/ofp-msgs.h"
+#line 306 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_port_stats),
-#line 2433 "lib/ofp-msgs.inc"
+#line 2468 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REPLY,
         "OFPST_PORT reply",
     },
     {
         ofpraw_ofpst13_port_reply_instances,
         4, 4,
-#line 305 "./lib/ofp-msgs.h"
+#line 308 "./lib/ofp-msgs.h"
         0,
-#line 305 "./lib/ofp-msgs.h"
+#line 308 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_port_stats),
-#line 2444 "lib/ofp-msgs.inc"
+#line 2479 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REPLY,
         "OFPST_PORT reply",
     },
     {
         ofpraw_ofpst14_port_reply_instances,
         5, 6,
-#line 307 "./lib/ofp-msgs.h"
+#line 310 "./lib/ofp-msgs.h"
         0,
-#line 307 "./lib/ofp-msgs.h"
+#line 310 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2455 "lib/ofp-msgs.inc"
+#line 2490 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_STATS_REPLY,
         "OFPST_PORT reply",
     },
     {
         ofpraw_ofpst10_queue_request_instances,
         1, 1,
-#line 310 "./lib/ofp-msgs.h"
+#line 313 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_queue_stats_request),
-#line 310 "./lib/ofp-msgs.h"
+#line 313 "./lib/ofp-msgs.h"
         0,
-#line 2466 "lib/ofp-msgs.inc"
+#line 2501 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REQUEST,
         "OFPST_QUEUE request",
     },
     {
         ofpraw_ofpst11_queue_request_instances,
         2, 6,
-#line 312 "./lib/ofp-msgs.h"
+#line 315 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_queue_stats_request),
-#line 312 "./lib/ofp-msgs.h"
+#line 315 "./lib/ofp-msgs.h"
         0,
-#line 2477 "lib/ofp-msgs.inc"
+#line 2512 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REQUEST,
         "OFPST_QUEUE request",
     },
     {
         ofpraw_ofpst10_queue_reply_instances,
         1, 1,
-#line 315 "./lib/ofp-msgs.h"
+#line 318 "./lib/ofp-msgs.h"
         0,
-#line 315 "./lib/ofp-msgs.h"
+#line 318 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_queue_stats),
-#line 2488 "lib/ofp-msgs.inc"
+#line 2523 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REPLY,
         "OFPST_QUEUE reply",
     },
     {
         ofpraw_ofpst11_queue_reply_instances,
         2, 3,
-#line 317 "./lib/ofp-msgs.h"
+#line 320 "./lib/ofp-msgs.h"
         0,
-#line 317 "./lib/ofp-msgs.h"
+#line 320 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_queue_stats),
-#line 2499 "lib/ofp-msgs.inc"
+#line 2534 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REPLY,
         "OFPST_QUEUE reply",
     },
     {
         ofpraw_ofpst13_queue_reply_instances,
         4, 4,
-#line 319 "./lib/ofp-msgs.h"
+#line 322 "./lib/ofp-msgs.h"
         0,
-#line 319 "./lib/ofp-msgs.h"
+#line 322 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_queue_stats),
-#line 2510 "lib/ofp-msgs.inc"
+#line 2545 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REPLY,
         "OFPST_QUEUE reply",
     },
     {
         ofpraw_ofpst14_queue_reply_instances,
         5, 6,
-#line 321 "./lib/ofp-msgs.h"
+#line 324 "./lib/ofp-msgs.h"
         0,
-#line 321 "./lib/ofp-msgs.h"
+#line 324 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2521 "lib/ofp-msgs.inc"
+#line 2556 "lib/ofp-msgs.inc"
         OFPTYPE_QUEUE_STATS_REPLY,
         "OFPST_QUEUE reply",
     },
     {
         ofpraw_ofpst11_group_request_instances,
         2, 6,
-#line 324 "./lib/ofp-msgs.h"
+#line 327 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_group_stats_request),
-#line 324 "./lib/ofp-msgs.h"
+#line 327 "./lib/ofp-msgs.h"
         0,
-#line 2532 "lib/ofp-msgs.inc"
+#line 2567 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_STATS_REQUEST,
         "OFPST_GROUP request",
     },
     {
         ofpraw_ofpst11_group_reply_instances,
         2, 3,
-#line 327 "./lib/ofp-msgs.h"
+#line 330 "./lib/ofp-msgs.h"
         0,
-#line 327 "./lib/ofp-msgs.h"
+#line 330 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2543 "lib/ofp-msgs.inc"
+#line 2578 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_STATS_REPLY,
         "OFPST_GROUP reply",
     },
     {
         ofpraw_ofpst13_group_reply_instances,
         4, 6,
-#line 329 "./lib/ofp-msgs.h"
+#line 332 "./lib/ofp-msgs.h"
         0,
-#line 329 "./lib/ofp-msgs.h"
+#line 332 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2554 "lib/ofp-msgs.inc"
+#line 2589 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_STATS_REPLY,
         "OFPST_GROUP reply",
     },
     {
         ofpraw_ofpst11_group_desc_request_instances,
         2, 5,
-#line 332 "./lib/ofp-msgs.h"
+#line 335 "./lib/ofp-msgs.h"
         0,
-#line 332 "./lib/ofp-msgs.h"
+#line 335 "./lib/ofp-msgs.h"
         0,
-#line 2565 "lib/ofp-msgs.inc"
+#line 2600 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_DESC_STATS_REQUEST,
         "OFPST_GROUP_DESC request",
     },
     {
         ofpraw_ofpst15_group_desc_request_instances,
         6, 6,
-#line 334 "./lib/ofp-msgs.h"
+#line 337 "./lib/ofp-msgs.h"
         sizeof(ovs_be32),
-#line 334 "./lib/ofp-msgs.h"
+#line 337 "./lib/ofp-msgs.h"
         0,
-#line 2576 "lib/ofp-msgs.inc"
+#line 2611 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_DESC_STATS_REQUEST,
         "OFPST_GROUP_DESC request",
     },
     {
         ofpraw_ofpst11_group_desc_reply_instances,
         2, 6,
-#line 337 "./lib/ofp-msgs.h"
+#line 340 "./lib/ofp-msgs.h"
         0,
-#line 337 "./lib/ofp-msgs.h"
+#line 340 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2587 "lib/ofp-msgs.inc"
+#line 2622 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_DESC_STATS_REPLY,
         "OFPST_GROUP_DESC reply",
     },
     {
         ofpraw_ofpst12_group_features_request_instances,
         3, 6,
-#line 340 "./lib/ofp-msgs.h"
+#line 343 "./lib/ofp-msgs.h"
         0,
-#line 340 "./lib/ofp-msgs.h"
+#line 343 "./lib/ofp-msgs.h"
         0,
-#line 2598 "lib/ofp-msgs.inc"
+#line 2633 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_FEATURES_STATS_REQUEST,
         "OFPST_GROUP_FEATURES request",
     },
     {
         ofpraw_ofpst12_group_features_reply_instances,
         3, 6,
-#line 343 "./lib/ofp-msgs.h"
+#line 346 "./lib/ofp-msgs.h"
         sizeof(struct ofp12_group_features_stats),
-#line 343 "./lib/ofp-msgs.h"
+#line 346 "./lib/ofp-msgs.h"
         0,
-#line 2609 "lib/ofp-msgs.inc"
+#line 2644 "lib/ofp-msgs.inc"
         OFPTYPE_GROUP_FEATURES_STATS_REPLY,
         "OFPST_GROUP_FEATURES reply",
     },
     {
         ofpraw_ofpst13_meter_request_instances,
         4, 6,
-#line 346 "./lib/ofp-msgs.h"
+#line 349 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_meter_multipart_request),
-#line 346 "./lib/ofp-msgs.h"
+#line 349 "./lib/ofp-msgs.h"
         0,
-#line 2620 "lib/ofp-msgs.inc"
+#line 2655 "lib/ofp-msgs.inc"
         OFPTYPE_METER_STATS_REQUEST,
         "OFPST_METER request",
     },
     {
         ofpraw_ofpst13_meter_reply_instances,
         4, 6,
-#line 349 "./lib/ofp-msgs.h"
+#line 352 "./lib/ofp-msgs.h"
         0,
-#line 349 "./lib/ofp-msgs.h"
+#line 352 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2631 "lib/ofp-msgs.inc"
+#line 2666 "lib/ofp-msgs.inc"
         OFPTYPE_METER_STATS_REPLY,
         "OFPST_METER reply",
     },
     {
         ofpraw_ofpst13_meter_config_request_instances,
         4, 6,
-#line 352 "./lib/ofp-msgs.h"
+#line 355 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_meter_multipart_request),
-#line 352 "./lib/ofp-msgs.h"
+#line 355 "./lib/ofp-msgs.h"
         0,
-#line 2642 "lib/ofp-msgs.inc"
+#line 2677 "lib/ofp-msgs.inc"
         OFPTYPE_METER_CONFIG_STATS_REQUEST,
         "OFPST_METER_CONFIG request",
     },
     {
         ofpraw_ofpst13_meter_config_reply_instances,
         4, 6,
-#line 355 "./lib/ofp-msgs.h"
+#line 358 "./lib/ofp-msgs.h"
         0,
-#line 355 "./lib/ofp-msgs.h"
+#line 358 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2653 "lib/ofp-msgs.inc"
+#line 2688 "lib/ofp-msgs.inc"
         OFPTYPE_METER_CONFIG_STATS_REPLY,
         "OFPST_METER_CONFIG reply",
     },
     {
         ofpraw_ofpst13_meter_features_request_instances,
         4, 6,
-#line 358 "./lib/ofp-msgs.h"
+#line 361 "./lib/ofp-msgs.h"
         0,
-#line 358 "./lib/ofp-msgs.h"
+#line 361 "./lib/ofp-msgs.h"
         0,
-#line 2664 "lib/ofp-msgs.inc"
+#line 2699 "lib/ofp-msgs.inc"
         OFPTYPE_METER_FEATURES_STATS_REQUEST,
         "OFPST_METER_FEATURES request",
     },
     {
         ofpraw_ofpst13_meter_features_reply_instances,
         4, 6,
-#line 361 "./lib/ofp-msgs.h"
+#line 364 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_meter_features),
-#line 361 "./lib/ofp-msgs.h"
+#line 364 "./lib/ofp-msgs.h"
         0,
-#line 2675 "lib/ofp-msgs.inc"
+#line 2710 "lib/ofp-msgs.inc"
         OFPTYPE_METER_FEATURES_STATS_REPLY,
         "OFPST_METER_FEATURES reply",
     },
     {
         ofpraw_ofpst13_table_features_request_instances,
         4, 6,
-#line 364 "./lib/ofp-msgs.h"
+#line 367 "./lib/ofp-msgs.h"
         0,
-#line 364 "./lib/ofp-msgs.h"
+#line 367 "./lib/ofp-msgs.h"
         0,
-#line 2686 "lib/ofp-msgs.inc"
+#line 2721 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_FEATURES_STATS_REQUEST,
         "OFPST_TABLE_FEATURES request",
     },
     {
         ofpraw_ofpst13_table_features_reply_instances,
         4, 6,
-#line 367 "./lib/ofp-msgs.h"
+#line 370 "./lib/ofp-msgs.h"
         sizeof(struct ofp13_table_features),
-#line 367 "./lib/ofp-msgs.h"
+#line 370 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2697 "lib/ofp-msgs.inc"
+#line 2732 "lib/ofp-msgs.inc"
         OFPTYPE_TABLE_FEATURES_STATS_REPLY,
         "OFPST_TABLE_FEATURES reply",
     },
     {
         ofpraw_ofpst10_port_desc_request_instances,
         1, 5,
-#line 370 "./lib/ofp-msgs.h"
+#line 373 "./lib/ofp-msgs.h"
         0,
-#line 370 "./lib/ofp-msgs.h"
+#line 373 "./lib/ofp-msgs.h"
         0,
-#line 2708 "lib/ofp-msgs.inc"
+#line 2743 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_DESC_STATS_REQUEST,
         "OFPST_PORT_DESC request",
     },
     {
         ofpraw_ofpst15_port_desc_request_instances,
         6, 6,
-#line 372 "./lib/ofp-msgs.h"
+#line 375 "./lib/ofp-msgs.h"
         sizeof(ovs_be32),
-#line 372 "./lib/ofp-msgs.h"
+#line 375 "./lib/ofp-msgs.h"
         0,
-#line 2719 "lib/ofp-msgs.inc"
+#line 2754 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_DESC_STATS_REQUEST,
         "OFPST_PORT_DESC request",
     },
     {
         ofpraw_ofpst10_port_desc_reply_instances,
         1, 1,
-#line 375 "./lib/ofp-msgs.h"
+#line 378 "./lib/ofp-msgs.h"
         0,
-#line 375 "./lib/ofp-msgs.h"
+#line 378 "./lib/ofp-msgs.h"
         sizeof(struct ofp10_phy_port),
-#line 2730 "lib/ofp-msgs.inc"
+#line 2765 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_DESC_STATS_REPLY,
         "OFPST_PORT_DESC reply",
     },
     {
         ofpraw_ofpst11_port_desc_reply_instances,
         2, 4,
-#line 377 "./lib/ofp-msgs.h"
+#line 380 "./lib/ofp-msgs.h"
         0,
-#line 377 "./lib/ofp-msgs.h"
+#line 380 "./lib/ofp-msgs.h"
         sizeof(struct ofp11_port),
-#line 2741 "lib/ofp-msgs.inc"
+#line 2776 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_DESC_STATS_REPLY,
         "OFPST_PORT_DESC reply",
     },
     {
         ofpraw_ofpst14_port_desc_reply_instances,
         5, 6,
-#line 379 "./lib/ofp-msgs.h"
+#line 382 "./lib/ofp-msgs.h"
         0,
-#line 379 "./lib/ofp-msgs.h"
+#line 382 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2752 "lib/ofp-msgs.inc"
+#line 2787 "lib/ofp-msgs.inc"
         OFPTYPE_PORT_DESC_STATS_REPLY,
         "OFPST_PORT_DESC reply",
     },
     {
+        ofpraw_ofpst11_monitor_stat_request_instances,
+        1, 6,
+#line 385 "./lib/ofp-msgs.h"
+        sizeof(struct ofp11_monitor_stats_request),
+#line 385 "./lib/ofp-msgs.h"
+        sizeof(uint8_t[8]),
+#line 2798 "lib/ofp-msgs.inc"
+        OFPTYPE_MONITOR_STATS_REQUEST,
+        "OFPST_MONITOR_STAT request",
+    },
+    {
+        ofpraw_ofpst11_monitor_stat_reply_instances,
+        1, 6,
+#line 387 "./lib/ofp-msgs.h"
+        0,
+#line 387 "./lib/ofp-msgs.h"
+        sizeof(struct ofp11_monitor_stats),
+#line 2809 "lib/ofp-msgs.inc"
+        OFPTYPE_MONITOR_STATS_REPLY,
+        "OFPST_MONITOR_STAT reply",
+    },
+    {
         ofpraw_nxt_set_flow_format_instances,
         1, 1,
-#line 387 "./lib/ofp-msgs.h"
+#line 395 "./lib/ofp-msgs.h"
         sizeof(struct nx_set_flow_format),
-#line 387 "./lib/ofp-msgs.h"
+#line 395 "./lib/ofp-msgs.h"
         0,
-#line 2763 "lib/ofp-msgs.inc"
+#line 2820 "lib/ofp-msgs.inc"
         OFPTYPE_SET_FLOW_FORMAT,
         "NXT_SET_FLOW_FORMAT",
     },
     {
         ofpraw_nxt_flow_mod_table_id_instances,
         1, 6,
-#line 390 "./lib/ofp-msgs.h"
+#line 398 "./lib/ofp-msgs.h"
         sizeof(struct nx_flow_mod_table_id),
-#line 390 "./lib/ofp-msgs.h"
+#line 398 "./lib/ofp-msgs.h"
         0,
-#line 2774 "lib/ofp-msgs.inc"
+#line 2831 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MOD_TABLE_ID,
         "NXT_FLOW_MOD_TABLE_ID",
     },
     {
         ofpraw_nxt_set_packet_in_format_instances,
         1, 6,
-#line 393 "./lib/ofp-msgs.h"
+#line 401 "./lib/ofp-msgs.h"
         sizeof(struct nx_set_packet_in_format),
-#line 393 "./lib/ofp-msgs.h"
+#line 401 "./lib/ofp-msgs.h"
         0,
-#line 2785 "lib/ofp-msgs.inc"
+#line 2842 "lib/ofp-msgs.inc"
         OFPTYPE_SET_PACKET_IN_FORMAT,
         "NXT_SET_PACKET_IN_FORMAT",
     },
     {
         ofpraw_nxt_flow_age_instances,
         1, 6,
-#line 396 "./lib/ofp-msgs.h"
+#line 404 "./lib/ofp-msgs.h"
         0,
-#line 396 "./lib/ofp-msgs.h"
+#line 404 "./lib/ofp-msgs.h"
         0,
-#line 2796 "lib/ofp-msgs.inc"
+#line 2853 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_AGE,
         "NXT_FLOW_AGE",
     },
     {
         ofpraw_nxt_set_controller_id_instances,
         1, 6,
-#line 399 "./lib/ofp-msgs.h"
+#line 407 "./lib/ofp-msgs.h"
         sizeof(struct nx_controller_id),
-#line 399 "./lib/ofp-msgs.h"
+#line 407 "./lib/ofp-msgs.h"
         0,
-#line 2807 "lib/ofp-msgs.inc"
+#line 2864 "lib/ofp-msgs.inc"
         OFPTYPE_SET_CONTROLLER_ID,
         "NXT_SET_CONTROLLER_ID",
     },
     {
         ofpraw_nxt_flow_monitor_cancel_instances,
         1, 6,
-#line 402 "./lib/ofp-msgs.h"
+#line 410 "./lib/ofp-msgs.h"
         sizeof(struct nx_flow_monitor_cancel),
-#line 402 "./lib/ofp-msgs.h"
+#line 410 "./lib/ofp-msgs.h"
         0,
-#line 2818 "lib/ofp-msgs.inc"
+#line 2875 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MONITOR_CANCEL,
         "NXT_FLOW_MONITOR_CANCEL",
     },
     {
         ofpraw_nxt_flow_monitor_paused_instances,
         1, 6,
-#line 405 "./lib/ofp-msgs.h"
+#line 413 "./lib/ofp-msgs.h"
         0,
-#line 405 "./lib/ofp-msgs.h"
+#line 413 "./lib/ofp-msgs.h"
         0,
-#line 2829 "lib/ofp-msgs.inc"
+#line 2886 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MONITOR_PAUSED,
         "NXT_FLOW_MONITOR_PAUSED",
     },
     {
         ofpraw_nxt_flow_monitor_resumed_instances,
         1, 6,
-#line 408 "./lib/ofp-msgs.h"
+#line 416 "./lib/ofp-msgs.h"
         0,
-#line 408 "./lib/ofp-msgs.h"
+#line 416 "./lib/ofp-msgs.h"
         0,
-#line 2840 "lib/ofp-msgs.inc"
+#line 2897 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MONITOR_RESUMED,
         "NXT_FLOW_MONITOR_RESUMED",
     },
     {
         ofpraw_nxst_flow_monitor_request_instances,
         1, 1,
-#line 416 "./lib/ofp-msgs.h"
+#line 424 "./lib/ofp-msgs.h"
         0,
-#line 416 "./lib/ofp-msgs.h"
+#line 424 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2851 "lib/ofp-msgs.inc"
+#line 2908 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MONITOR_STATS_REQUEST,
         "NXST_FLOW_MONITOR request",
     },
     {
         ofpraw_nxst_flow_monitor_reply_instances,
         1, 1,
-#line 419 "./lib/ofp-msgs.h"
+#line 427 "./lib/ofp-msgs.h"
         0,
-#line 419 "./lib/ofp-msgs.h"
+#line 427 "./lib/ofp-msgs.h"
         sizeof(uint8_t[8]),
-#line 2862 "lib/ofp-msgs.inc"
+#line 2919 "lib/ofp-msgs.inc"
         OFPTYPE_FLOW_MONITOR_STATS_REPLY,
         "NXST_FLOW_MONITOR reply",
     },
diff -Naur openvswitch-2.3.2/lib/ofp-parse.c umon_ovs2.3/lib/ofp-parse.c
--- openvswitch-2.3.2/lib/ofp-parse.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-parse.c	2016-06-23 10:10:03.801595514 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 
 #include "ofp-parse.h"
@@ -40,6 +59,10 @@
 #include "socket-util.h"
 #include "vconn.h"
 
+/* UMON: monitor table modifications. */
+static char * WARN_UNUSED_RESULT
+monitor_parse__(char *arg, struct ofpbuf *b, enum ofputil_protocol *usable_protocols);
+
 /* Parses 'str' as an 8-bit unsigned integer into '*valuep'.
  *
  * 'name' describes the value parsed in an error message, if any.
@@ -330,6 +353,53 @@
     return NULL;
 }
 
+/* UMON: monitor table modifications. */
+static char * WARN_UNUSED_RESULT
+monitor_parse(char *arg, struct ofpbuf *b, enum ofputil_protocol *usable_protocols)
+{
+    char *copy = xstrdup(arg);
+    char *error = monitor_parse__(copy, b, usable_protocols);
+    free(copy);
+    return error;
+}
+
+/* UMON: monitor table modifications. */
+static char * WARN_UNUSED_RESULT
+prtscan_parse(char *arg, struct ofpbuf *b)
+{
+    struct ofpact_prtscan_detection *ofpd = ofpact_put_PRTSCAN_DETECTION(b);
+    char *key, *value;
+
+    while(ofputil_parse_key_value(&arg, &key, &value)) {
+	char *error;
+	
+
+	if(!strcmp(key, "detector_switch")) {
+	    error = str_to_u8(value, key, &ofpd->detector_switch);
+	    if(ofpd->detector_switch != 0 && ofpd->detector_switch != 1){
+		error = xasprintf("invalid switch flag '%s' in 'port scan detection' argument", value);
+	    }
+	} else if(!strcmp(key, "delete_flows")) {
+	    error = str_to_u8(value, key, &ofpd->delete_flows);
+	    if(ofpd->delete_flows != 0 && ofpd->delete_flows != 1){
+		error = xasprintf("invalid delete flag '%s' in 'port scan detection' argument", value);
+	    }
+	} else if(!strcmp(key, "interval")) {
+	    error = str_to_u64(value, &ofpd->interval);
+	    if(ofpd->interval % 5 != 0) {
+		error = xasprintf("invalid interval '%s' in 'port scan detection' argument", value);
+	    }
+	} else {
+		error = xasprintf("invalid key '%s' in 'port scan detection' argument", key);
+	}
+	if(error)
+		return error;
+    }
+    return NULL;
+}
+
+
+
 /* Parses 'arg' as the argument to a "controller" action, and appends such an
  * action to 'ofpacts'.
  *
@@ -644,6 +714,7 @@
     uint8_t ttl = 0;
     uint8_t pcp = 0;
 
+
     switch (code) {
     case OFPUTIL_ACTION_INVALID:
         OVS_NOT_REACHED();
@@ -906,9 +977,19 @@
 
     case OFPUTIL_OFPAT11_GROUP:
     case OFPUTIL_OFPAT13_GROUP:
-        error = str_to_u32(arg, &ofpact_put_GROUP(ofpacts)->group_id);
+	
         break;
 
+    /* UMON: monitor table modifications. */
+    case OFPUTIL_OFPAT11_MONITOR:
+    case OFPUTIL_OFPAT13_MONITOR:
+	return monitor_parse(arg, ofpacts, usable_protocols);
+
+    /* UMON: monitor table modifications. */
+    case OFPUTIL_OFPAT11_PRTSCAN_DETECTION:
+    case OFPUTIL_OFPAT13_PRTSCAN_DETECTION:
+	return prtscan_parse(arg, ofpacts);
+
     /* FIXME when implement OFPAT13_* */
     case OFPUTIL_OFPAT13_COPY_TTL_OUT:
     case OFPUTIL_OFPAT13_COPY_TTL_IN:
@@ -1224,6 +1305,60 @@
     return error;
 }
 
+
+/* UMON: monitor table modifications. */
+static char * WARN_UNUSED_RESULT
+monitor_parse__(char *arg, struct ofpbuf *b, enum ofputil_protocol *usable_protocols)
+{
+    struct ofpact_monitor *ofm = ofpact_put_MONITOR(b);
+    char *key, *value;
+    while (ofputil_parse_key_value(&arg, &key, &value)) {
+	char *error;
+	if(!strcmp(key, "monitor_flag")) {
+		error = str_to_u32(value, &ofm->monitor_flag);
+		if(leftmost_1bit_idx(ofm->monitor_flag) >= 10) {
+			error = xasprintf("unsupported monitor flag '%s' in 'monitor' argument", value);
+		}
+	} else if(!strcmp(key, "subflow_flag")) {
+		error = str_to_u8(value, key, &ofm->subflow_flag);
+		if(ofm->subflow_flag != 0 && ofm->subflow_flag != 1) {
+			error = xasprintf("invalid subflow flag '%s' in 'monitor' argument", value);
+		}
+	} else if(!strcmp(key,"submatch")) {
+		char *name;
+		char *save_ptr = NULL;
+		for (name = strtok_r(value, "=, \t\r\n", &save_ptr); name;
+		         name = strtok_r(NULL, "=, \t\r\n", &save_ptr)) {
+			const struct protocol *p;
+			if (parse_protocol(name, &p)) {
+         		   match_set_dl_type(&ofm->subflow_match, htons(p->dl_type));
+		           if (p->nw_proto) {
+                		match_set_nw_proto(&ofm->subflow_match, p->nw_proto);
+			   }
+			} else {
+				char *subvalue;
+				subvalue = strtok_r(NULL, ", \t\r\n", &save_ptr);
+				if (!subvalue) {
+             			   error = xasprintf("field %s missing value", name);
+            			}
+				if (mf_from_name(name)) {
+					error = parse_field(mf_from_name(name), subvalue, &ofm->subflow_match,
+                                    usable_protocols);
+				} else {
+			                error = xasprintf("unknown keyword %s", name);
+            			}
+				
+			}
+            	}
+	} else {
+		error = xasprintf("invalid key '%s' in 'monitor' argument", key);
+	}
+	if(error)
+		return error;
+    }
+    return NULL;
+}
+
 static char * WARN_UNUSED_RESULT
 parse_ofp_str__(struct ofputil_flow_mod *fm, int command, char *string,
                 enum ofputil_protocol *usable_protocols)
diff -Naur openvswitch-2.3.2/lib/ofp-print.c umon_ovs2.3/lib/ofp-print.c
--- openvswitch-2.3.2/lib/ofp-print.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-print.c	2016-06-23 10:10:16.409565236 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "ofp-print.h"
 
@@ -2422,6 +2441,21 @@
     ofputil_format_group(group_id, string);
 }
 
+/* UMON: monitor stats request. */
+static void
+ofp_print_ofpst_monitor_stats_request(struct ds *string, const struct ofp_header *oh)
+{
+    enum ofperr error;
+    struct ofputil_monitor_stats_request msr;
+    error = ofputil_decode_monitor_stats_request(oh, &msr);
+    if (error) { 
+	ofp_print_error(string, error);
+	return;
+    }
+
+    ofputil_format_monitor_request(&msr, string);
+}
+
 static void
 ofp_print_group_stats(struct ds *s, const struct ofp_header *oh)
 {
@@ -2546,6 +2580,67 @@
     ofputil_bucket_list_destroy(&gm.buckets);
 }
 
+/* UMON: monitor table modifications. */
+static void
+ofp_print_monitor_mod(struct ds *s, const struct ofp_header *oh)
+{
+    struct ofputil_monitor_mod om;
+    struct ofpbuf ofpacts;
+    enum ofperr error;
+
+    ofpbuf_init(&ofpacts, 64);
+    error = ofputil_decode_monitor_mod(&om, oh, &ofpacts);
+    if(error) {
+	ofpbuf_uninit(&ofpacts);
+	ofp_print_error(s, error);
+	return;
+    }
+
+    ds_put_char(s, ' ');
+    switch(om.command) {
+    case OFPMMC_ADD:
+	ds_put_cstr(s, "ADD");
+	break;
+
+    case OFPMMC_MODIFY:
+	ds_put_cstr(s, "MOD");
+	break;
+
+    case OFPMMC_MODIFY_STRICT:
+	ds_put_cstr(s, "MOD_STRICT");
+	break;
+
+    case OFPMMC_DELETE:
+	ds_put_cstr(s, "DEL");
+	break;
+	
+    case OFPMMC_DELETE_STRICT:
+	ds_put_cstr(s, "DEL_STRICT");
+	break;
+    case OFPMMC_DELETE_MICFLOWS:
+	ds_put_cstr(s, "DEL_MICFLOWS");
+	break;
+    default:
+	ds_put_format(s, "cmd:%"PRIu16"", om.command);
+    }
+    ds_put_char(s, ' ');
+    match_format(&om.match, s, OFP_DEFAULT_PRIORITY);
+
+    if (ds_last(s) != ' ') {
+        ds_put_char(s, ' ');
+    }
+
+    if (om.idle_timeout != OFP_FLOW_PERMANENT) {
+        ds_put_format(s, "idle:%"PRIu16" ", om.idle_timeout);
+    }
+    if (om.hard_timeout != OFP_FLOW_PERMANENT) {
+        ds_put_format(s, "hard:%"PRIu16" ", om.hard_timeout);
+    }
+    ds_put_cstr(s, "actions=");
+    ofpacts_format(om.ofpacts, om.ofpacts_len, s);
+    ofpbuf_uninit(&ofpacts);
+}
+
 static const char *
 ofp13_action_to_string(uint32_t bit)
 {
@@ -2828,6 +2923,21 @@
     case OFPTYPE_GROUP_MOD:
         ofp_print_group_mod(string, oh);
         break;
+    /* UMON: monitor table modifications. */
+    case OFPTYPE_MONITOR_MOD:
+	ofp_print_monitor_mod(string, oh);
+	break;
+
+    /* UMON: monitor stats request. */
+    case OFPTYPE_MONITOR_STATS_REQUEST:
+    case OFPTYPE_MONITOR_STATS_REPLY:
+	ofp_print_stats_request(string, oh);
+	ofp_print_ofpst_monitor_stats_request(string, oh);
+	break;
+
+    /* UMON: prtscan detection alert. */
+    case OFPTYPE_PRTSCAN_ALERT:
+	break;
 
     case OFPTYPE_TABLE_FEATURES_STATS_REQUEST:
     case OFPTYPE_TABLE_FEATURES_STATS_REPLY:
diff -Naur openvswitch-2.3.2/lib/ofp-util.c umon_ovs2.3/lib/ofp-util.c
--- openvswitch-2.3.2/lib/ofp-util.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-util.c	2016-06-23 10:10:28.297536952 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "ofp-print.h"
 #include <ctype.h>
@@ -44,6 +63,7 @@
 #include "vlog.h"
 #include "bitmap.h"
 
+
 VLOG_DEFINE_THIS_MODULE(ofp_util);
 
 /* Rate limit for OpenFlow message parse errors.  These always indicate a bug
@@ -335,6 +355,8 @@
         return ofputil_match_from_ofp11_match(om, match);
     }
 
+    /* UMON: monitor table modifications. */
+    case OFPMT_MONITOR:
     case OFPMT_OXM:
         if (padded_match_len) {
             *padded_match_len = ROUND_UP(match_len, 8);
@@ -1771,6 +1793,78 @@
                                      fm->table_id, max_table, protocol);
 }
 
+/* UMON: monitor stats request. */
+enum ofperr
+ofputil_decode_monitor_stats_request(const struct ofp_header *request,
+				     struct ofputil_monitor_stats_request *msr)
+{
+    enum ofperr error;
+    struct ofpbuf b;
+    enum ofpraw raw;
+    const struct ofp11_monitor_stats_request *omsr;
+
+    ofpbuf_use_const(&b, request, ntohs(request->length));
+    raw = ofpraw_pull_assert(&b);
+    if(raw == OFPRAW_OFPST11_MONITOR_STAT_REQUEST) {
+	omsr = ofpbuf_pull(&b, sizeof *omsr);
+	if(omsr->type == OFPMR_EXACT) {
+	    error = ofputil_pull_ofp11_match(&b, &msr->match, NULL);
+	    if(error) {
+		return error;
+	    }
+	}
+	msr->with_subflows = omsr->with_subflows;
+	msr->type = omsr->type;
+	msr->request_id = ntohl(omsr->request_id);
+        msr->pkt_threshold = ntohl(omsr->pkt_threshold);
+	msr->byte_threshold = ntohl(omsr->byte_threshold);
+
+	return 0;
+    } else {
+        OVS_NOT_REACHED();
+    }
+}
+
+
+/* UMON: monitor table modifications. */
+enum ofperr ofputil_decode_monitor_mod(struct ofputil_monitor_mod *fmm,
+                                       const struct ofp_header *oh,
+                                       struct ofpbuf *ofpacts)
+{
+    enum ofperr error;
+    struct ofpbuf b;
+    enum ofpraw raw;
+    const struct ofp11_monitor_mod *ofmm;
+
+    ofpbuf_use_const(&b, oh, ntohs(oh->length));
+    raw = ofpraw_pull_assert(&b);
+    if(raw == OFPRAW_OFPT11_MONITOR_MOD) {
+        ofmm = ofpbuf_pull(&b, sizeof *ofmm);
+        error = ofputil_pull_ofp11_match(&b, &fmm->match, NULL);
+        if (error) {
+            return error;
+        }
+        error = ofpacts_pull_openflow_instructions(&b, ofpbuf_size(&b), oh->version,
+                                                   ofpacts);
+        if (error) {
+            return error;
+        }
+
+        fmm->command = ofmm->command;
+        fmm->idle_timeout = ntohs(ofmm->idle_timeout);
+        fmm->hard_timeout = ntohs(ofmm->hard_timeout);
+        fmm->ofpacts = ofpbuf_data(ofpacts);
+        fmm->ofpacts_len = ofpbuf_size(ofpacts);
+
+	return 0;
+    }
+    else {
+        OVS_NOT_REACHED();
+    }
+}
+
+
+
 static enum ofperr
 ofputil_pull_bands(struct ofpbuf *msg, size_t len, uint16_t *n_bands,
                    struct ofpbuf *bands)
@@ -3008,6 +3102,53 @@
     ofpmp_postappend(replies, start_ofs);
 }
 
+/* UMON: monitor stats request */
+void 
+ofputil_append_monitor_stats_reply(const struct ofputil_monitor_stats *ms,
+                                        struct list *replies)
+{
+    struct ofpbuf *reply = ofpbuf_from_list(list_back(replies));
+    size_t start_oms = ofpbuf_size(reply);
+    enum ofp_version version = ofpmp_version(replies);
+    struct ofp11_monitor_stats *oms;
+    struct ofputil_monitor_micflow *micflow;
+  
+    ofpbuf_put_zeros(reply, sizeof *oms);
+    oxm_put_monitor_match(reply, &ms->match, version);
+    ofpbuf_put(reply, ms->monitor_stats, sizeof(uint64_t)*ms->stat_count);
+
+    if(ms->n_micflows) {
+    	LIST_FOR_EACH(micflow, list_node, &ms->flows) {
+    	    struct ofp11_monitor_micflow *omm;
+    	    size_t start_omm;
+
+    	    start_omm = ofpbuf_size(reply);
+    	    ofpbuf_put_zeros(reply, sizeof *omm);
+    	    oxm_put_match(reply, &micflow->micflow_match, version);
+    	    omm = ofpbuf_at_assert(reply, start_omm, sizeof *omm);
+    	    omm->length = htons(ofpbuf_size(reply) - start_omm);
+	    omm->tcp_flags = micflow->tcp_flags;
+    	    omm->packet_count = htonll(unknown_to_zero(micflow->packet_count));
+    	    omm->byte_count = htonll(unknown_to_zero(micflow->byte_count));
+    	    omm->duration_sec = htonl(micflow->duration_sec);
+    	    omm->duration_nsec = htonl(micflow->duration_nsec);
+    	    list_remove(&micflow->list_node);
+    	}
+    }
+    oms = ofpbuf_at_assert(reply, start_oms, sizeof *oms);
+    oms->length = htons(ofpbuf_size(reply) - start_oms);
+    oms->request_id = htonl(ms->request_id);
+    oms->duration_sec = htonl(ms->duration_sec);
+    oms->duration_nsec = htonl(ms->duration_nsec);
+    oms->idle_age = htonl(ms->idle_age);
+    oms->hard_age = htonl(ms->hard_age);
+    oms->stat_count = ms->stat_count;
+    oms->n_micflows = htons(ms->n_micflows);
+
+    ofpmp_postappend(replies, start_oms);
+
+}
+
 /* Converts abstract ofputil_aggregate_stats 'stats' into an OFPST_AGGREGATE or
  * NXST_AGGREGATE reply matching 'request', and returns the message. */
 struct ofpbuf *
@@ -3446,6 +3587,65 @@
     return packet;
 }
 
+/* UMON: monitor prtscan detection alert */
+struct ofpbuf *
+ofputil_encode_prtscan_alert(const struct ofputil_prtscan_alert * pat)
+{
+    struct ofp11_prtscan_alert *opa;
+    struct ofpbuf *alert;
+    int attacker_size, victim_size, micflow_size;
+    size_t start_opa;
+    struct ofputil_monitor_micflow *micflow;
+
+    attacker_size = pat->n_attackers * 15 * sizeof(char);
+    victim_size = pat->n_victims * 15 * sizeof(char);
+    micflow_size = pat->n_micflows * sizeof(struct ofp11_monitor_micflow);
+  
+    if (attacker_size && victim_size) { 
+        alert = ofpraw_alloc_xid(OFPRAW_OFPT11_PRTSCAN_ALERT, OFP14_VERSION, htonl(0), NXM_TYPICAL_LEN+attacker_size + victim_size + sizeof(uint64_t)*pat->stat_count+sizeof(uint16_t)*pat->n_ports+1);
+    } else{
+        alert = ofpraw_alloc_xid(OFPRAW_OFPT11_PRTSCAN_ALERT, OFP14_VERSION, htonl(0), NXM_TYPICAL_LEN+sizeof(uint64_t)*pat->stat_count+sizeof(uint16_t)*pat->n_ports+micflow_size);
+    }
+    start_opa = ofpbuf_size(alert);
+    ofpbuf_put_zeros(alert, sizeof *opa);
+    oxm_put_monitor_match(alert, &pat->match, OFP14_VERSION);
+    ofpbuf_put(alert, pat->monitor_stats, sizeof(uint64_t)*pat->stat_count);
+    ofpbuf_put(alert, pat->ports, sizeof(uint16_t)*pat->n_ports);
+    if(pat->n_micflows) {
+    	LIST_FOR_EACH(micflow, list_node, &pat->flows) {
+    	    struct ofp11_monitor_micflow *omm;
+    	    size_t start_omm;
+
+    	    start_omm = ofpbuf_size(alert);
+    	    ofpbuf_put_zeros(alert, sizeof *omm);
+    	    oxm_put_match(alert, &micflow->micflow_match, OFP14_VERSION);
+    	    omm = ofpbuf_at_assert(alert, start_omm, sizeof *omm);
+    	    omm->length = htons(ofpbuf_size(alert) - start_omm);
+	    omm->tcp_flags = micflow->tcp_flags;
+    	    omm->packet_count = htonll(unknown_to_zero(micflow->packet_count));
+    	    omm->byte_count = htonll(unknown_to_zero(micflow->byte_count));
+    	    omm->duration_sec = htonl(micflow->duration_sec);
+    	    omm->duration_nsec = htonl(micflow->duration_nsec);
+    	    list_remove(&micflow->list_node);
+    	}
+    }
+    if(attacker_size && victim_size) {
+        ofpbuf_put(alert, pat->attackers, attacker_size);
+        ofpbuf_put(alert, ",", 1);
+        ofpbuf_put(alert, pat->victims, victim_size);
+    }
+    opa = ofpbuf_at_assert(alert, start_opa, sizeof *opa);
+    opa->duration_sec = htonl(pat->duration_sec);
+    opa->duration_nsec = htonl(pat->duration_nsec);
+    opa->stat_count = pat->stat_count;
+    opa->detection_type = pat->detection_type;
+    opa->n_ports = htons(pat->n_ports);
+    opa->n_attackers = htons(pat->n_attackers);
+    opa->n_victims = htons(pat->n_victims);
+    opa->n_micflows = htonl(pat->n_micflows);
+    return alert;
+}
+
 static struct ofpbuf *
 ofputil_encode_ofp12_packet_in(const struct ofputil_packet_in *pin,
                                enum ofputil_protocol protocol)
@@ -3550,6 +3750,91 @@
     }
 }
 
+/* UMON: monitor action format. */
+const char *
+ofputil_prtscan_type_to_string(uint8_t detection_type)
+{
+	uint8_t type;
+	int pos, old_pos;
+	struct ds string;
+	ds_init(&string);
+	old_pos = -1;
+	for(type = detection_type; type; type=zero_rightmost_1bit(type)) {
+		pos = rightmost_1bit_idx(type);
+		if (old_pos != pos && old_pos != -1)
+                        ds_put_cstr(&string,"/");
+		switch(pos) {
+		case 0:
+			if(old_pos == 0 || old_pos != pos)
+				ds_put_cstr(&string, "vertical");
+			break;
+		case 1:
+			if(old_pos == 0 || old_pos != pos)
+				ds_put_cstr(&string, "horizontal");
+			break;
+		}
+		old_pos = pos;
+        }
+        return ds_cstr(&string);
+}
+
+/* UMON: monitor action format. */
+const char *
+ofputil_monitor_flag_to_string(uint32_t monitor_flag)
+{
+        uint32_t flag;
+        int pos, old_pos;
+        struct ds string;
+        ds_init(&string);
+        old_pos = -1;
+        for(flag = monitor_flag; flag; flag = zero_rightmost_1bit(flag)) {
+                pos = rightmost_1bit_idx(flag);
+                if (old_pos != pos && old_pos != -1)
+                        ds_put_cstr(&string,", ");
+                switch(pos) {
+                case 0:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor FIN packets");
+                        break;
+                case 1:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor SYN packets");
+                        break;
+                case 2:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor ACK packets");
+                        break;
+                case 3:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor RST packets");
+                        break;
+                case 4:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor FIN/ACK packets");
+                        break;
+                case 5:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor SYN/ACK packets");
+                        break;
+                case 6:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor RST/ACK packets");
+                        break;
+                case 7:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor ICMP echo request packets");
+                        break;
+                case 8:
+                        if(old_pos == 0 || old_pos != pos)
+                                ds_put_cstr(&string,"monitor ICMP echo reply packets");
+                        break;
+                }
+                old_pos = pos;
+        }
+        return ds_cstr(&string);
+}
+
+
 bool
 ofputil_packet_in_reason_from_string(const char *s,
                                      enum ofp_packet_in_reason *reason)
@@ -5789,6 +6074,27 @@
     ds_put_cstr(s, name);
 }
 
+/* UMON: monitor stats request */ 
+void 
+ofputil_format_monitor_request(struct ofputil_monitor_stats_request *msr, struct ds *s)
+{
+    if(msr->with_subflows) {
+	ds_put_cstr(s, " ,with_subflows=TRUE");
+    } else{
+	ds_put_cstr(s, " ,with_subflows=FALSE");
+    }
+    switch(msr->type){
+    case OFPMR_ALL:
+	ds_put_cstr(s, " ,type=ALL");
+	break;
+    case OFPMR_EXACT:
+	ds_put_cstr(s, " ,type=EXACT");
+	break;
+    default:
+	break;
+    }
+    match_format(&msr->match, s, OFP_DEFAULT_PRIORITY);
+}
 
 /* Puts in the 'bufsize' byte in 'namebuf' a null-terminated string
  * representation of OpenFlow group ID 'group_id'.  Most group are represented
@@ -6586,6 +6892,7 @@
     }
 }
 
+
 /* Returns an OpenFlow group stats request for OpenFlow version 'ofp_version',
  * that requests stats for group 'group_id'.  (Use OFPG_ALL to request stats
  * for all groups.)
@@ -6841,6 +7148,7 @@
     return 0;
 }
 
+
 /* Converts a group stats reply in 'msg' into an abstract ofputil_group_stats
  * in 'gs'.  Assigns freshly allocated memory to gs->bucket_stats for the
  * caller to eventually free.
diff -Naur openvswitch-2.3.2/lib/ofp-util.def umon_ovs2.3/lib/ofp-util.def
--- openvswitch-2.3.2/lib/ofp-util.def	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-util.def	2016-03-16 10:54:57.000000000 -0400
@@ -22,6 +22,9 @@
 OFPAT11_ACTION(OFPAT11_OUTPUT,       ofp11_action_output, 0, "output")
 OFPAT11_ACTION(OFPAT11_SET_VLAN_VID, ofp_action_vlan_vid, 0, "set_vlan_vid")
 OFPAT11_ACTION(OFPAT11_SET_VLAN_PCP, ofp_action_vlan_pcp, 0, "set_vlan_pcp")
+/* UMON: monitor table modifications. */
+OFPAT11_ACTION(OFPAT11_MONITOR, ofp11_action_monitor,1,"monitor")
+OFPAT11_ACTION(OFPAT11_PRTSCAN_DETECTION, ofp11_action_prtscan_detection,0,"prtscan_detection")
 OFPAT11_ACTION(OFPAT11_SET_DL_SRC,   ofp_action_dl_addr,  0, "mod_dl_src")
 OFPAT11_ACTION(OFPAT11_SET_DL_DST,   ofp_action_dl_addr,  0, "mod_dl_dst")
 OFPAT11_ACTION(OFPAT11_SET_NW_SRC,   ofp_action_nw_addr,  0, "mod_nw_src")
@@ -63,6 +66,9 @@
 OFPAT13_ACTION(OFPAT13_SET_FIELD,    ofp12_action_set_field, 1, "set_field")
 OFPAT13_ACTION(OFPAT13_PUSH_PBB,     ofp11_action_push,      0, "push_pbb")
 OFPAT13_ACTION(OFPAT13_POP_PBB,      ofp_action_header,      0, "pop_pbb")
+/* UMON: monitor table modifications. */
+OFPAT13_ACTION(OFPAT13_MONITOR, ofp11_action_monitor,1,"monitor")
+OFPAT13_ACTION(OFPAT13_PRTSCAN_DETECTION, ofp11_action_prtscan_detection,0,"prtscan_detection")
 
 #ifndef NXAST_ACTION
 #define NXAST_ACTION(ENUM, STRUCT, EXTENSIBLE, NAME)
diff -Naur openvswitch-2.3.2/lib/ofp-util.h umon_ovs2.3/lib/ofp-util.h
--- openvswitch-2.3.2/lib/ofp-util.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/ofp-util.h	2016-06-23 10:12:48.881200082 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFP_UTIL_H
 #define OFP_UTIL_H 1
 
@@ -34,6 +53,7 @@
 union ofp_action;
 struct ofpact_set_field;
 
+
 /* Port numbers. */
 enum ofperr ofputil_port_from_ofp11(ovs_be32 ofp11_port,
                                     ofp_port_t *ofp10_port);
@@ -309,6 +329,19 @@
     size_t ofpacts_len;      /* Length of ofpacts, in bytes. */
 };
 
+/* UMON: monitor table modifications */
+struct ofputil_monitor_mod {
+    struct list list_node;    /* For queuing monitor_mods. */
+
+    struct match match;
+    uint16_t command;
+    uint16_t idle_timeout;
+    uint16_t hard_timeout;
+    struct ofpact *ofpacts;  /* Series of "struct ofpact"s. */
+    size_t ofpacts_len;      /* Length of ofpacts, in bytes. */
+};
+
+
 enum ofperr ofputil_decode_flow_mod(struct ofputil_flow_mod *,
                                     const struct ofp_header *,
                                     enum ofputil_protocol,
@@ -318,6 +351,15 @@
 struct ofpbuf *ofputil_encode_flow_mod(const struct ofputil_flow_mod *,
                                        enum ofputil_protocol);
 
+/* UMON: monitor table modifications */
+enum ofperr ofputil_decode_monitor_mod(struct ofputil_monitor_mod *,
+                                       const struct ofp_header *,
+                                       struct ofpbuf *ofpacts);
+/* UMON: monitor table modifications */
+struct ofpbuf *ofputil_encode_monitor_mod(const struct ofputil_monitor_mod *,
+                                          enum ofputil_protocol);
+
+
 /* Flow stats or aggregate stats request, independent of protocol. */
 struct ofputil_flow_stats_request {
     bool aggregate;             /* Aggregate results? */
@@ -329,6 +371,22 @@
     uint8_t table_id;
 };
 
+/* UMON: monitor stats request. */
+struct ofputil_monitor_stats_request {
+    bool with_subflows;
+    uint8_t type;
+    ovs_be32 request_id;
+    ovs_be32 pkt_threshold;
+    ovs_be32 byte_threshold;
+    struct match match;
+};
+
+/* UMON: monitor stats request. */
+void ofputil_format_monitor_request(struct ofputil_monitor_stats_request *msr, struct ds *);
+/* UMON: monitor stats request. */
+enum ofperr ofputil_decode_monitor_stats_request(const struct ofp_header *request,
+                                     struct ofputil_monitor_stats_request *msr);
+
 enum ofperr ofputil_decode_flow_stats_request(
     struct ofputil_flow_stats_request *, const struct ofp_header *);
 struct ofpbuf *ofputil_encode_flow_stats_request(
@@ -348,11 +406,56 @@
     int hard_age;               /* Seconds since last change, -1 if unknown. */
     uint64_t packet_count;      /* Packet count, UINT64_MAX if unknown. */
     uint64_t byte_count;        /* Byte count, UINT64_MAX if unknown. */
+
     const struct ofpact *ofpacts;
     size_t ofpacts_len;
     enum ofputil_flow_mod_flags flags;
 };
 
+/* UMON: prtscan detection alert. */
+struct ofputil_prtscan_alert {
+    struct match match;
+    uint32_t duration_sec;
+    uint32_t duration_nsec;
+    uint8_t stat_count;
+    uint8_t detection_type;
+    uint64_t *monitor_stats;
+    uint16_t *ports;
+    int n_ports;
+    int n_attackers;
+    int n_victims;
+    int n_micflows;
+    char *attackers;
+    char *victims;
+    struct list flows;
+};
+
+/* UMON: monitor stats request. */
+struct ofputil_monitor_stats {
+    struct match match;
+    uint32_t request_id;
+    uint32_t duration_sec;
+    uint32_t duration_nsec;
+    int idle_age;	/* Seconds since last packet, -1 if unknown. */
+    int hard_age;	/* Seconds since last change, -1 if unknown. */
+    
+    size_t stat_count;
+    uint64_t *monitor_stats;
+    int n_micflows;
+    struct list flows;
+};
+
+/* UMON: monitor stats request */
+struct ofputil_monitor_micflow {
+    struct list list_node;
+    uint16_t tcp_flags;
+    uint64_t packet_count;
+    uint64_t byte_count;
+    uint32_t duration_sec;
+    uint32_t duration_nsec;
+    struct match micflow_match;
+};
+
 int ofputil_decode_flow_stats_reply(struct ofputil_flow_stats *,
                                     struct ofpbuf *msg,
                                     bool flow_age_extension,
@@ -360,6 +463,10 @@
 void ofputil_append_flow_stats_reply(const struct ofputil_flow_stats *,
                                      struct list *replies);
 
+/* UMON: monitor stats request */
+void ofputil_append_monitor_stats_reply(const struct ofputil_monitor_stats *,
+					struct list *replies);
+
 /* Aggregate stats reply, independent of protocol. */
 struct ofputil_aggregate_stats {
     uint64_t packet_count;      /* Packet count, UINT64_MAX if unknown. */
@@ -430,11 +537,21 @@
 struct ofpbuf *ofputil_encode_packet_in(const struct ofputil_packet_in *,
                                         enum ofputil_protocol protocol,
                                         enum nx_packet_in_format);
+/* UMON: monitor prtscan detection alert. */
+struct ofpbuf *ofputil_encode_prtscan_alert(const struct ofputil_prtscan_alert *);
 
 enum { OFPUTIL_PACKET_IN_REASON_BUFSIZE = INT_STRLEN(int) + 1 };
 const char *ofputil_packet_in_reason_to_string(enum ofp_packet_in_reason,
                                                char *reasonbuf,
                                                size_t bufsize);
+
+/* UMON */
+const char *ofputil_prtscan_type_to_string(uint8_t type);
+/* UMON */
+const char *ofputil_monitor_flag_to_string(uint32_t monitor_flag);
+
+
+
 bool ofputil_packet_in_reason_from_string(const char *,
                                           enum ofp_packet_in_reason *);
 
@@ -1121,6 +1238,10 @@
                                                   uint32_t group_id);
 enum ofperr ofputil_decode_group_stats_request(
     const struct ofp_header *request, uint32_t *group_id);
+/* UMON: monitor stats request. */
+enum ofperr ofputil_decode_monitor_stats_reques(
+    const struct ofp_header *request, struct ofputil_monitor_stats_request *msr);
+
 void ofputil_append_group_stats(struct list *replies,
                                 const struct ofputil_group_stats *);
 struct ofpbuf *ofputil_encode_group_features_request(enum ofp_version);
diff -Naur openvswitch-2.3.2/lib/rconn.c umon_ovs2.3/lib/rconn.c
--- openvswitch-2.3.2/lib/rconn.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/rconn.c	2016-06-23 10:13:02.721167301 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "rconn.h"
 #include <errno.h>
@@ -1384,6 +1403,11 @@
     case OFPTYPE_TABLE_FEATURES_STATS_REPLY:
     case OFPTYPE_BUNDLE_CONTROL:
     case OFPTYPE_BUNDLE_ADD_MESSAGE:
+    /* UMON: monitor stats requst. */
+    case OFPTYPE_MONITOR_STATS_REQUEST:
+    case OFPTYPE_MONITOR_STATS_REPLY:
+    /* UMON: prtscan detection alert. */
+    case OFPTYPE_PRTSCAN_ALERT:
         return false;
 
     case OFPTYPE_PACKET_IN:
@@ -1431,6 +1455,7 @@
     case OFPTYPE_FLOW_MONITOR_CANCEL:
     case OFPTYPE_FLOW_MONITOR_PAUSED:
     case OFPTYPE_FLOW_MONITOR_RESUMED:
+    case OFPTYPE_MONITOR_MOD:
     default:
         return true;
     }
diff -Naur openvswitch-2.3.2/lib/sset.c umon_ovs2.3/lib/sset.c
--- openvswitch-2.3.2/lib/sset.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/sset.c	2016-06-23 10:13:16.953132848 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 
 #include "sset.h"
@@ -127,6 +146,31 @@
             : sset_add__(set, name, length, hash));
 }
 
+/* UMON: monitor table modifications. */
+struct sset_node *
+sset_add_port(struct sset *set, const char *name)
+{
+    size_t length = strlen(name);
+    uint32_t hash = hash_name__(name, length);
+    struct sset_node *node;
+    int count = 1;
+    char new_name[32];
+
+    HMAP_FOR_EACH_WITH_HASH (node, hmap_node, hash, &set->map) {
+        if (!strncmp(node->name, name, length)) {
+	    char *token;
+	    token = strtok(node->name, ".");
+	    token = strtok(NULL, ".");
+	    count = atoi(token) + count;
+    	    sprintf(new_name, "%s.%d", name, count);
+	    memcpy(node->name, new_name, strlen(new_name));
+	    return node;
+        }
+    }
+    sprintf(new_name, "%s.%d", name, count);
+    return sset_add__(set, new_name, strlen(new_name), hash);
+}
+
 /* Adds a copy of 'name' to 'set' and frees 'name'.
  *
  * If 'name' is new, returns the new sset_node; otherwise (if a copy of 'name'
diff -Naur openvswitch-2.3.2/lib/sset.h umon_ovs2.3/lib/sset.h
--- openvswitch-2.3.2/lib/sset.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/lib/sset.h	2016-06-23 10:13:27.473107871 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef SSET_H
 #define SSET_H
 
@@ -49,6 +68,8 @@
 
 /* Insertion. */
 struct sset_node *sset_add(struct sset *, const char *);
+/* UMON: monitor table modifications. */
+struct sset_node *sset_add_port(struct sset*, const char *);
 struct sset_node *sset_add_and_free(struct sset *, char *);
 void sset_add_assert(struct sset *, const char *);
 void sset_add_array(struct sset *, char **, size_t n);
diff -Naur openvswitch-2.3.2/ofproto/connmgr.c umon_ovs2.3/ofproto/connmgr.c
--- openvswitch-2.3.2/ofproto/connmgr.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/connmgr.c	2016-06-23 10:14:52.824902396 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 
 #include "connmgr.h"
@@ -1814,6 +1833,19 @@
                   &txq);
     do_send_packet_ins(ofconn, &txq);
 }
+
+/* UMON: send portscan alert to controller */
+void 
+connmgr_send_prtscan_alert(struct connmgr* mgr, const struct ofputil_prtscan_alert *alert)
+{
+    struct ofconn *ofconn;
+    LIST_FOR_EACH(ofconn, node, &mgr->all_conns) {
+        struct ofpbuf *alert_buf = ofputil_encode_prtscan_alert(alert);
+        rconn_send(ofconn->rconn, alert_buf, NULL);
+    }
+}
+
+
 
 /* Fail-open settings. */
 
diff -Naur openvswitch-2.3.2/ofproto/connmgr.h umon_ovs2.3/ofproto/connmgr.h
--- openvswitch-2.3.2/ofproto/connmgr.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/connmgr.h	2016-06-23 10:15:09.240863942 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef CONNMGR_H
 #define CONNMGR_H 1
 
@@ -174,6 +193,9 @@
                             const struct ofproto_packet_in *);
 void ofconn_send_role_status(struct ofconn *ofconn, uint32_t role,
                              uint8_t reason);
+/* UMON: prtscan detection alert.*/
+void connmgr_send_prtscan_alert(struct connmgr*,
+			       const struct ofputil_prtscan_alert *);
 
 /* Fail-open settings. */
 enum ofproto_fail_mode connmgr_get_fail_mode(const struct connmgr *);
diff -Naur openvswitch-2.3.2/ofproto/ofproto.c umon_ovs2.3/ofproto/ofproto.c
--- openvswitch-2.3.2/ofproto/ofproto.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto.c	2016-06-23 10:15:27.544819775 -0400
@@ -15,6 +15,30 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
+/* UMON: portscan detections */
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
 #include <config.h>
 #include "ofproto.h"
 #include <errno.h>
@@ -160,6 +184,13 @@
     OVS_REQUIRES(ofproto_mutex);
 static void oftable_insert_rule(struct rule *);
 
+/* UMON: monitor table modifications. */
+/* functions related to monitor table */
+static void oftable_remove_monitor_rule(struct monitor_rule *mrule) OVS_REQUIRES(ofproto_mutex);
+static void oftable_remove_monitor_rule__(struct ofproto *, struct monitor_rule *)
+    OVS_REQUIRES(ofproto_mutex);
+static void oftable_insert_monitor_rule(struct monitor_rule *);
+
 /* A set of rules within a single OpenFlow table (oftable) that have the same
  * values for the oftable's eviction_fields.  A rule to be evicted, when one is
  * needed, is taken from the eviction group that contains the greatest number
@@ -271,6 +302,12 @@
 static void do_add_flow(struct ofproto *, struct ofconn *,
                         const struct ofp_header *request, uint32_t buffer_id,
                         struct rule *);
+
+/* UMON: monitor table modifications */
+/* insert monitoring rule based on ofputil_monitor_mod */
+static enum ofperr add_monitor_flow(struct ofproto *, struct ofputil_monitor_mod *);
+                                    
+
 static enum ofperr modify_flows__(struct ofproto *, struct ofconn *,
                                   struct ofputil_flow_mod *,
                                   const struct ofp_header *,
@@ -290,6 +327,13 @@
                                      struct ofputil_flow_mod *,
                                      const struct ofp_header *)
     OVS_EXCLUDED(ofproto_mutex);
+
+/* UMON: monitor table modifications */
+static enum ofperr handle_monitor_mod__(struct ofproto *, struct ofconn *,
+                                     struct ofputil_monitor_mod *,
+                                     const struct ofp_header *)
+    OVS_EXCLUDED(ofproto_mutex);
+
 static void calc_duration(long long int start, long long int now,
                           uint32_t *sec, uint32_t *nsec);
 
@@ -614,6 +658,15 @@
     }
 }
 
+/* UMON: monitor table modifications. */
+/* called by an ofproto implementation in its constructor function. */
+void ofproto_init_mtable(struct ofproto *ofproto)
+{
+        ofproto->mtable = xmalloc(sizeof *ofproto->mtable);
+        oftable_init(ofproto->mtable);
+        atomic_init(&ofproto->mtable_timestamp, 0);
+}
+
 /* To be optionally called (only) by an ofproto implementation in its
  * constructor function.  See the large comment on 'construct' in struct
  * ofproto_class for details.
@@ -1989,6 +2042,7 @@
     return handle_flow_mod__(ofproto, NULL, fm, NULL);
 }
 
+
 /* Searches for a rule with matching criteria exactly equal to 'target' in
  * ofproto's table 0 and, if it finds one, deletes it.
  *
@@ -2577,7 +2631,7 @@
         }
     }
 }
-
+
 static void
 ofproto_rule_destroy__(struct rule *rule)
     OVS_NO_THREAD_SAFETY_ANALYSIS
@@ -2588,6 +2642,24 @@
     rule->ofproto->ofproto_class->rule_dealloc(rule);
 }
 
+/* UMON: monitor table modifications. */
+static void
+ofproto_monitor_rule_destroy__(struct monitor_rule *mrule)
+{
+    cls_rule_destroy(CONST_CAST(struct cls_rule *, &mrule->cr));
+    rule_actions_destroy(monitor_rule_get_actions(mrule));
+    ovs_mutex_destroy(&mrule->mutex);
+    mrule->ofproto->ofproto_class->monitor_rule_dealloc(mrule);
+}
+
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_destroy_cb(struct monitor_rule *mrule)
+{
+    mrule->ofproto->ofproto_class->monitor_rule_destruct(mrule);
+    ofproto_monitor_rule_destroy__(mrule);
+}
+
 static void
 rule_destroy_cb(struct rule *rule)
 {
@@ -2595,6 +2667,16 @@
     ofproto_rule_destroy__(rule);
 }
 
+/* UMON: monitor table modifications. */
+void
+ofproto_monitor_rule_ref(struct monitor_rule *mrule)
+{
+    if (mrule) {
+        ovs_refcount_ref(&mrule->ref_count);
+    }
+
+}
+
 void
 ofproto_rule_ref(struct rule *rule)
 {
@@ -2603,6 +2685,17 @@
     }
 }
 
+
+/* UMON: monitor table modifications. */
+void
+ofproto_monitor_rule_unref(struct monitor_rule *mrule)
+{
+    if (mrule && ovs_refcount_unref(&mrule->ref_count) == 1) {
+        ovsrcu_postpone(monitor_rule_destroy_cb, mrule);
+    }
+
+}
+
 /* Decrements 'rule''s ref_count and schedules 'rule' to be destroyed if the
  * ref_count reaches 0.
  *
@@ -3347,6 +3440,23 @@
     rules->capacity = ARRAY_SIZE(rules->stub);
 }
 
+/* UMON: monitor table modifications. */
+void 
+monitor_rule_collection_init(struct monitor_rule_collection *mrules)
+{
+    mrules->rules = mrules->stub;
+    mrules->n = 0;
+    mrules->capacity = ARRAY_SIZE(mrules->stub);
+}
+
+/* UMON: monitor table modifications. */
+void
+monitor_flow_dump_collection_init(struct monitor_flow_dump_collection *flows)
+{
+        flows->n = 0;
+        hmap_init(&flows->micflows);
+}
+
 void
 rule_collection_add(struct rule_collection *rules, struct rule *rule)
 {
@@ -3368,6 +3478,38 @@
     rules->rules[rules->n++] = rule;
 }
 
+/* UMON: monitor table modifications. */
+void 
+monitor_rule_collection_add(struct monitor_rule_collection *mrules, struct monitor_rule *mrule)
+{
+    if (mrules->n >= mrules->capacity) {
+        size_t old_size, new_size;
+
+        old_size = mrules->capacity * sizeof *mrules->rules;
+        mrules->capacity *= 2;
+        new_size = mrules->capacity * sizeof *mrules->rules;
+
+        if (mrules->rules == mrules->stub) {
+            mrules->rules = xmalloc(new_size);
+            memcpy(mrules->rules, mrules->stub, old_size);
+        } else {
+            mrules->rules = xrealloc(mrules->rules, new_size);
+        }
+    }
+
+    mrules->rules[mrules->n++] = mrule;
+}
+
+/* UMON: monitor table modifications. */
+void
+monitor_flow_dump_collection_add(struct monitor_flow_dump_collection *flows, struct monitor_flow_dump *flow, uint32_t hash)
+{
+        struct hmap_node * node = get_node_from_dump(flow);
+        hmap_insert(&flows->micflows, node, hash);
+        flows->n++;
+}
+
+
 void
 rule_collection_ref(struct rule_collection *rules)
     OVS_REQUIRES(ofproto_mutex)
@@ -3379,6 +3521,18 @@
     }
 }
 
+/* UMON: monitor table modifications. */
+void 
+monitor_rule_collection_ref(struct monitor_rule_collection *mrules)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    size_t i;
+
+    for (i = 0; i < mrules->n; i++) {
+        ofproto_monitor_rule_ref(mrules->rules[i]);
+    }
+}
+
 void
 rule_collection_unref(struct rule_collection *rules)
 {
@@ -3389,6 +3543,18 @@
     }
 }
 
+/* UMON: monitor table modifications. */
+void 
+monitor_rule_collection_unref(struct monitor_rule_collection *mrules)
+{
+    size_t i;
+
+    for (i = 0; i < mrules->n; i++) {
+        ofproto_monitor_rule_unref(mrules->rules[i]);
+    }
+
+}
+
 void
 rule_collection_destroy(struct rule_collection *rules)
 {
@@ -3397,6 +3563,15 @@
     }
 }
 
+/* UMON: monitor table modifications. */
+void 
+monitor_rule_collection_destroy(struct monitor_rule_collection *mrules)
+{
+    if (mrules->rules != mrules->stub) {
+        free(mrules->rules);
+    }
+}
+
 static enum ofperr
 collect_rule(struct rule *rule, const struct rule_criteria *c,
              struct rule_collection *rules)
@@ -3545,6 +3720,27 @@
     return error;
 }
 
+/* UMON: monitor table modifications */
+static enum ofperr
+collect_monitor_rules_strict(struct ofproto *ofproto,
+			     const struct rule_criteria *criteria,
+			     struct monitor_rule_collection *mrules)
+	OVS_REQUIRES(ofproto_mutex)
+{
+    struct oftable *table;
+    struct monitor_rule *mrule;
+
+    monitor_rule_collection_init(mrules);
+    table = ofproto->mtable;
+    fat_rwlock_rdlock(&table->cls.rwlock);
+    mrule = monitor_rule_from_cls_rule(classifier_find_rule_exactly(&table->cls, &criteria->cr));
+    fat_rwlock_unlock(&table->cls.rwlock);
+    if (mrule) {
+	monitor_rule_collection_add(mrules, mrule);
+    }
+    return 0;
+}
+
 /* Returns 'age_ms' (a duration in milliseconds), converted to seconds and
  * forced into the range of a uint16_t. */
 static int
@@ -3631,6 +3827,107 @@
     return 0;
 }
 
+/* UMON: monitor stats request. */
+static enum ofperr
+handle_monitor_stats_request(struct ofconn *ofconn,
+			     const struct ofp_header *request)
+	OVS_EXCLUDED(ofproto_mutex)
+{
+    struct ofproto *ofproto = ofconn_get_ofproto(ofconn);
+    struct ofputil_monitor_stats_request msr;
+    enum ofperr error;
+    struct list replies;
+    struct oftable *mtable;
+    struct cls_cursor cursor;
+    struct monitor_rule *mrule;
+    struct match mrule_match;
+    struct monitor_rule_collection rules;
+    size_t i;
+
+    
+    error = ofputil_decode_monitor_stats_request(request, &msr);
+    if(error) { 
+	return error;
+    }
+
+    monitor_rule_collection_init(&rules);
+    ovs_mutex_lock(&ofproto_mutex);
+    mtable = ofproto->mtable;
+    cls_cursor_init(&cursor, &mtable->cls, NULL);
+    fat_rwlock_rdlock(&mtable->cls.rwlock);
+    CLS_CURSOR_FOR_EACH(mrule, cr, &cursor) {
+         minimatch_expand(&mrule->cr.match, &mrule_match);
+         if(msr.type == OFPMR_ALL || match_equal(&msr.match, &mrule_match)) {
+	     monitor_rule_collection_add(&rules,mrule);
+	 }
+    }
+    fat_rwlock_unlock(&mtable->cls.rwlock);
+    monitor_rule_collection_ref(&rules);
+    ovs_mutex_unlock(&ofproto_mutex);
+
+    for (i=0; i<rules.n; i++) {
+	long long int now = time_msec();
+        long long int created, modified, used;
+        struct ofputil_monitor_stats ms;
+        uint64_t *monitor_stats;
+
+    	ofpmp_init(&replies, request);
+	mrule = rules.rules[i];
+
+        ovs_mutex_lock(&mrule->mutex);
+        created = mrule->created;
+        modified = mrule->modified;
+        ovs_mutex_unlock(&mrule->mutex);
+
+        ofproto->ofproto_class->monitor_rule_get_stat_count(mrule, &ms.stat_count);
+        monitor_stats = (uint64_t *)xmalloc(sizeof(uint64_t)*ms.stat_count);
+        ofproto->ofproto_class->monitor_rule_get_stats(mrule, monitor_stats, &used);
+        ms.monitor_stats = monitor_stats;
+        minimatch_expand(&mrule->cr.match, &ms.match);
+        calc_duration(created, modified, &ms.duration_sec, &ms.duration_nsec);
+        ms.idle_age = age_secs(now - used);
+        ms.hard_age = age_secs(now - modified);
+	if(mrule->subflow_flag || mrule->detector_switch) {
+            ofproto->ofproto_class->monitor_rule_get_micflows(mrule, &ms.flows, msr.pkt_threshold, msr.byte_threshold); 
+	    ms.n_micflows = list_size(&ms.flows);
+	} else {
+	    ms.n_micflows = 0;
+	}
+	ms.request_id = msr.request_id;
+	while(ms.n_micflows >= 450) {
+	    struct ofputil_monitor_stats subms;
+	    size_t i = 0;
+	    memcpy(&subms.match, &ms.match, sizeof(struct match));
+	    subms.duration_sec = ms.duration_sec;
+	    subms.duration_nsec = ms.duration_nsec;
+	    subms.idle_age = ms.idle_age;
+	    subms.hard_age = ms.hard_age;
+	    subms.stat_count = ms.stat_count;
+	    subms.request_id = ms.request_id;
+	    subms.monitor_stats = (uint64_t *)xmalloc(sizeof(uint64_t)*subms.stat_count);
+	    memcpy(subms.monitor_stats, ms.monitor_stats, sizeof(uint64_t)*subms.stat_count);
+	    subms.n_micflows = 450;	
+	    list_init(&subms.flows);
+
+	    while(i < 450){
+		list_push_back(&subms.flows, list_pop_front(&ms.flows));
+		i++;
+	    }
+	    ofputil_append_monitor_stats_reply(&subms, &replies);	    
+	    ms.n_micflows -= 450;
+    	    ofconn_send_replies(ofconn, &replies);
+	    ofpmp_init(&replies, request);
+	}
+        ofputil_append_monitor_stats_reply(&ms, &replies);
+        ofconn_send_replies(ofconn, &replies);
+    }
+
+    monitor_rule_collection_unref(&rules);
+    monitor_rule_collection_destroy(&rules);
+    return 0;
+}
+
+
 static void
 flow_stats_ds(struct rule *rule, struct ds *results)
 {
@@ -3661,6 +3958,52 @@
     ds_put_cstr(results, "\n");
 }
 
+/* UMON: monitor table modifications. */
+static void
+monitor_flow_stats_ds(struct monitor_rule *mrule, struct ds *results)
+{
+    uint64_t *monitor_stats;
+    const struct rule_actions *mactions;
+    long long int created, used;
+    monitor_stats = xmalloc(sizeof(uint64_t)*14);
+    mrule->ofproto->ofproto_class->monitor_rule_get_stats(mrule, monitor_stats, &used);
+
+    ovs_mutex_lock(&mrule->mutex);
+    mactions = monitor_rule_get_actions(mrule);
+    created = mrule->created;
+    ovs_mutex_unlock(&mrule->mutex);
+ 
+    ds_put_format(results, "table_id=%"PRIu8", ", 255);
+    ds_put_format(results, "duration=%llds, ", (time_msec() - created) / 1000);
+    ds_put_format(results, "n_packets=%"PRIu64", ", monitor_stats[0]);
+    ds_put_format(results, "n_bytes=%"PRIu64", ", monitor_stats[1]);
+    ds_put_format(results, "n_fin_packets=%"PRIu64", ", monitor_stats[2]);
+    ds_put_format(results, "n_syn_packets=%"PRIu64", ", monitor_stats[3]);
+    ds_put_format(results, "n_ack_packets=%"PRIu64", ", monitor_stats[4]);
+    ds_put_format(results, "n_rst_packets=%"PRIu64", ", monitor_stats[5]);
+    ds_put_format(results, "n_finack_packets=%"PRIu64", ", monitor_stats[6]);
+    ds_put_format(results, "n_synack_packets=%"PRIu64", ", monitor_stats[7]);
+    ds_put_format(results, "n_rstack_packets=%"PRIu64", ", monitor_stats[8]);
+    ds_put_format(results, "n_icmp_echoreq_packets=%"PRIu64", ", monitor_stats[9]);
+    ds_put_format(results, "n_icmp_echorep_packets=%"PRIu64", ", monitor_stats[10]); 
+
+    ds_put_format(results, "horizontal anomaly=%lu, ",monitor_stats[11]);
+    ds_put_format(results, "vertical anomaly=%lu, ",monitor_stats[12]);
+    ds_put_format(results, "number of micro flows=%lu, ", monitor_stats[13]);
+    cls_rule_format(&mrule->cr, results);
+    ds_put_char(results, ',');
+
+    ds_put_cstr(results, "actions=");
+    ofpacts_format(mactions->ofpacts, mactions->ofpacts_len, results);
+
+    ds_put_cstr(results, "\n");
+    if(monitor_stats[13]){
+        ds_put_char(results, '\t');
+        mrule->ofproto->ofproto_class->micflow_dump_format(results, mrule);
+    }
+    free(monitor_stats);
+}
+
 /* Adds a pretty-printed description of all flows to 'results', including
  * hidden flows (e.g., set up by in-band control). */
 void
@@ -3681,6 +4024,23 @@
     }
 }
 
+/* UMON: monitor table modifications. */
+void ofproto_get_all_monitor_flows(struct ofproto *p, struct ds *results)
+{
+    struct oftable *table;
+    struct monitor_rule *mrule;
+    struct cls_cursor cursor;
+
+    table = p->mtable;
+    fat_rwlock_rdlock(&table->cls.rwlock);
+    cls_cursor_init(&cursor, &table->cls, NULL);
+    CLS_CURSOR_FOR_EACH (mrule, cr, &cursor) {
+	monitor_flow_stats_ds(mrule, results);
+    }
+    fat_rwlock_unlock(&table->cls.rwlock);
+
+}
+
 /* Obtains the NetFlow engine type and engine ID for 'ofproto' into
  * '*engine_type' and '*engine_id', respectively. */
 void
@@ -3958,6 +4318,9 @@
     struct cls_rule cr;
     struct rule *rule;
     uint8_t table_id;
+    /* UMON: monitor table modifications. */
+    unsigned long long int table_timestamp;
+    unsigned long long int mrule_timestamp;
     int error = 0;
 
     if (!check_table_id(ofproto, fm->table_id)) {
@@ -4078,6 +4441,10 @@
                rule_actions_create(ofproto, fm->ofpacts, fm->ofpacts_len));
     list_init(&rule->meter_list_node);
     rule->eviction_group = NULL;
+    /* UMON: monitor table modifications. */
+    atomic_init(&rule->monitor_rule_timestamps, 0); 
+    rule->monitor_rules = NULL;
+
     list_init(&rule->expirable);
     rule->monitor_flags = 0;
     rule->add_seqno = 0;
@@ -4093,6 +4460,193 @@
     /* Insert rule. */
     do_add_flow(ofproto, ofconn, request, fm->buffer_id, rule);
 
+    /* UMON: monitor table modifications. */
+
+    atomic_read(&rule->ofproto->mtable_timestamp, &table_timestamp);
+    atomic_read(&rule->monitor_rule_timestamps, &mrule_timestamp);
+    if(!rule->monitor_rules && mrule_timestamp < table_timestamp){
+	rule->monitor_rules = xmalloc(sizeof(struct monitor_rule_collection));
+	monitor_rule_collection_init(rule->monitor_rules);
+
+	ofproto->ofproto_class->collect_monitor_rules(ofproto, rule);
+	if(!rule->monitor_rules->n) {
+            monitor_rule_collection_destroy(rule->monitor_rules);
+            rule->monitor_rules = NULL;
+	    goto exit;
+	}
+    }
+
+exit:
+    return error;
+}
+
+/* UMON: monitor table modifications */
+static enum ofperr
+add_monitor_flow(struct ofproto *ofproto, struct ofputil_monitor_mod *fmm)
+        OVS_REQUIRES(ofproto_mutex)
+{
+    struct oftable *monitor_table;
+    struct cls_rule cr;
+    struct monitor_rule *mrule;
+    int error = 0;
+    uint64_t orig;
+    struct ofpact *a;
+    struct ofpact_monitor *monitor;
+    struct ofpact_prtscan_detection *pd;
+    struct rule_collection matching_rules;
+    int i;
+    FILE *fd;
+    struct timeval triggered;
+    struct ds match_ds;
+
+
+    monitor_table = ofproto->mtable;
+    cls_rule_init(&cr, &fmm->match, 0);
+
+    fat_rwlock_rdlock(&monitor_table->cls.rwlock);
+    mrule = monitor_rule_from_cls_rule(classifier_find_rule_exactly(&monitor_table->cls, &cr));
+    fat_rwlock_unlock(&monitor_table->cls.rwlock);
+    if(mrule) {
+	struct ds match_ds;
+	ds_init(&match_ds);
+	match_format(&fmm->match, &match_ds, OFP_DEFAULT_PRIORITY);
+	VLOG_INFO("overlap match: %s\n", ds_cstr(&match_ds));
+	cls_rule_destroy(&cr);
+	return OFPERR_OFPMMC_OVERLAP;
+    }
+
+    /* Check whether we have enough space for one more monitor rule. */
+    if(should_evict_a_rule(monitor_table, 1)) {
+        cls_rule_destroy(&cr);
+        return OFPERR_OFPMMC_TABLE_FULL;
+    }
+
+    /* Allocate new rule. */
+    mrule = ofproto->ofproto_class->monitor_rule_alloc();
+    if(!mrule) {
+	cls_rule_destroy(&cr);
+        VLOG_WARN_RL(&rl, "%s: failed to create monitor rule (%s)",
+                         ofproto->name, ovs_strerror(error));
+        return ENOMEM;
+    }
+
+    /* Initialize base state. */
+    *CONST_CAST(struct ofproto **, &mrule->ofproto) = ofproto;
+    cls_rule_move(CONST_CAST(struct cls_rule *, &mrule->cr), &cr);
+
+    ovs_mutex_init(&mrule->mutex);
+    ovs_mutex_lock(&mrule->mutex);
+    mrule->idle_timeout = fmm->idle_timeout;
+    mrule->hard_timeout = fmm->hard_timeout;
+
+    ovsrcu_set(&mrule->monitor_actions, rule_actions_create(ofproto, fmm->ofpacts, fmm->ofpacts_len));
+    ovs_refcount_init(&mrule->ref_count);
+    mrule->created = mrule->modified = time_msec(); 
+    mrule->monitor_flag = 0;
+    mrule->subflow_flag = 0;
+    mrule->detector_switch = 0;
+    mrule->delete_flows = 1;
+    mrule->prtscan_type = 0;
+    mrule->anomaly_detection_interval = 0;
+    mrule->next_detection_time = 0;
+    mrule->vertical_threshold = 0;
+    mrule->horizontal_threshold = 0;
+
+    OFPACT_FOR_EACH(a, fmm->ofpacts, fmm->ofpacts_len) {
+	switch(a->type){ 
+	case OFPACT_MONITOR:
+	    ds_init(&match_ds);
+	    match_format(&fmm->match, &match_ds, OFP_DEFAULT_PRIORITY);
+	    fd = fopen("./trigger_timestamp.txt","a+");
+	    gettimeofday(&triggered, NULL);	
+	    fprintf(fd, "timestamp: %zd.%zd, match: %s\n", triggered.tv_sec, triggered.tv_usec, ds_cstr(&match_ds));
+	    fclose(fd);
+	    monitor = ofpact_get_MONITOR(a);
+	    mrule->monitor_flag = monitor->monitor_flag;
+	    mrule->subflow_flag = monitor->subflow_flag;
+	    break;
+        case OFPACT_PRTSCAN_DETECTION:
+	    pd = ofpact_get_PRTSCAN_DETECTION(a);
+	    mrule->delete_flows = pd->delete_flows;
+	    mrule->detector_switch = pd->detector_switch;
+	    mrule->prtscan_type = pd->detection_type;
+	    mrule->anomaly_detection_interval = pd->interval;
+	    mrule->next_detection_time = mrule->anomaly_detection_interval / 5;
+	    mrule->vertical_threshold = pd->vthresh;
+	    mrule->horizontal_threshold = pd->hthresh;
+	    break;
+	case OFPACT_OUTPUT:
+	case OFPACT_GROUP:
+	case OFPACT_CONTROLLER:
+	case OFPACT_ENQUEUE:
+	case OFPACT_OUTPUT_REG:
+	case OFPACT_BUNDLE:
+	case OFPACT_SET_FIELD:
+	case OFPACT_SET_VLAN_VID:
+	case OFPACT_SET_VLAN_PCP:
+	case OFPACT_STRIP_VLAN:
+	case OFPACT_PUSH_VLAN:
+	case OFPACT_SET_ETH_SRC:
+	case OFPACT_SET_ETH_DST:
+	case OFPACT_SET_IPV4_SRC:
+	case OFPACT_SET_IPV4_DST:
+	case OFPACT_SET_IP_DSCP:
+	case OFPACT_SET_IP_ECN:
+	case OFPACT_SET_IP_TTL:
+	case OFPACT_SET_L4_SRC_PORT:
+	case OFPACT_SET_L4_DST_PORT:
+	case OFPACT_REG_MOVE:
+	case OFPACT_REG_LOAD:
+	case OFPACT_STACK_PUSH:
+	case OFPACT_STACK_POP:
+	case OFPACT_DEC_TTL:
+	case OFPACT_SET_MPLS_LABEL:
+	case OFPACT_SET_MPLS_TC:
+	case OFPACT_SET_MPLS_TTL:
+	case OFPACT_DEC_MPLS_TTL:
+	case OFPACT_PUSH_MPLS:
+	case OFPACT_POP_MPLS:
+	case OFPACT_SET_TUNNEL:
+	case OFPACT_SET_QUEUE:
+	case OFPACT_POP_QUEUE:
+	case OFPACT_FIN_TIMEOUT:
+	case OFPACT_RESUBMIT:
+	case OFPACT_LEARN:
+	case OFPACT_MULTIPATH:
+	case OFPACT_NOTE:
+	case OFPACT_EXIT:
+	case OFPACT_SAMPLE:
+	case OFPACT_METER:
+	case OFPACT_CLEAR_ACTIONS:
+	case OFPACT_WRITE_ACTIONS:
+	case OFPACT_WRITE_METADATA:
+	case OFPACT_GOTO_TABLE:
+	default:
+	    break;
+	}
+    }
+    ovs_mutex_unlock(&mrule->mutex);
+
+    error = ofproto->ofproto_class->monitor_rule_construct(mrule);
+    if(error) {
+	ofproto_monitor_rule_destroy__(mrule);
+	return error;
+    }
+
+    oftable_insert_monitor_rule(mrule);
+    atomic_add(&ofproto->mtable_timestamp, 1 , &orig);
+
+    /* collect matching forwarding rules. */
+    rule_collection_init(&matching_rules);
+    ofproto->ofproto_class->collect_matching_forwarding_rules(mrule, &matching_rules);
+    for(i=0; i < matching_rules.n; i++){
+	struct rule* forwarding_rule = matching_rules.rules[i];
+	ofproto->ofproto_class->split_monitor_rules(forwarding_rule);
+    }
+
+    if(mrule->detector_switch) {
+	ofproto->ofproto_class->prtscan_detector_switch(ofproto, true);
+    }
     return error;
 }
 
@@ -4272,6 +4826,134 @@
 
     return error;
 }
+
+/* UMON: monitor table modifications. */
+static enum ofperr
+modify_monitor_flow_strict(struct ofproto *ofproto, const struct ofputil_monitor_mod *fmm)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    struct rule_criteria monitor_criteria;
+    struct monitor_rule_collection mrules;
+    const struct rule_actions * mrule_actions, *new_actions;
+    struct monitor_rule * mrule;
+    enum ofperr error;
+    size_t i;
+    bool actions_changed, subflow_collection_flag;
+
+    /* modify monitor rules from monitor table. */   
+    rule_criteria_init(&monitor_criteria, 0, &fmm->match, 0, htonll(0), htonll(0),
+                       OFPP_ANY, OFPG11_ANY);
+
+    error = collect_monitor_rules_strict(ofproto, &monitor_criteria, &mrules);
+    if(!error && mrules.n > 0) {
+	for(i = 0; i < mrules.n; i++) {
+	    mrule = mrules.rules[i];
+	    mrule_actions = monitor_rule_get_actions(mrule);
+	    actions_changed = !ofpacts_equal(fmm->ofpacts, fmm->ofpacts_len, mrule_actions->ofpacts, mrule_actions->ofpacts_len);
+	    ovs_mutex_lock(&mrule->mutex);
+	    mrule->idle_timeout = fmm->idle_timeout;
+	    mrule->hard_timeout = fmm->hard_timeout;
+	    ovs_mutex_unlock(&mrule->mutex);
+
+	    if (actions_changed) {
+		struct ofpact *a;
+		struct ofpact_monitor *monitor;
+		struct ofpact_prtscan_detection *pd;
+
+		subflow_collection_flag = false;
+		new_actions = rule_actions_create(ofproto, fmm->ofpacts, fmm->ofpacts_len);
+		ovsrcu_set(&mrule->monitor_actions, new_actions);
+		/* extract monitor actions to get subflow collection flag. */	
+		OFPACT_FOR_EACH(a, fmm->ofpacts, fmm->ofpacts_len) {
+		    switch(a->type) {
+		    case OFPACT_MONITOR:
+			monitor = ofpact_get_MONITOR(a);
+			if (monitor->subflow_flag == 1) {
+			    FILE *fd;
+			    struct timeval triggered;
+			    struct ds match_ds;
+			    ds_init(&match_ds);
+			    match_format(&fmm->match, &match_ds, OFP_DEFAULT_PRIORITY);
+			    fd = fopen("./trigger_timestamp.txt","a+");
+			    gettimeofday(&triggered, NULL);	
+			    fprintf(fd, "timestamp: %zd.%zd, match: %s\n", triggered.tv_sec, triggered.tv_usec, ds_cstr(&match_ds));
+			    fclose(fd);
+			    subflow_collection_flag = true;
+			}
+			break;
+		    case OFPACT_PRTSCAN_DETECTION:
+			pd = ofpact_get_PRTSCAN_DETECTION(a);
+			if (pd->detector_switch) {
+			    subflow_collection_flag = true;
+	    		    mrule->delete_flows = pd->delete_flows;
+	    		    mrule->prtscan_type = pd->detection_type;
+	    		    mrule->anomaly_detection_interval = pd->interval;
+	    		    mrule->next_detection_time = mrule->anomaly_detection_interval / 5;
+	    		    mrule->vertical_threshold = pd->vthresh;
+	    		    mrule->horizontal_threshold = pd->hthresh;
+			    mrule->detector_switch = 1;
+			} else {
+			    mrule->detector_switch = 0;
+			}
+			break;
+		    case OFPACT_GROUP:
+		    case OFPACT_CONTROLLER:
+		    case OFPACT_ENQUEUE:
+		    case OFPACT_OUTPUT_REG:
+		    case OFPACT_BUNDLE:
+		    case OFPACT_SET_FIELD:
+		    case OFPACT_SET_VLAN_VID:
+		    case OFPACT_SET_VLAN_PCP:
+		    case OFPACT_STRIP_VLAN:
+		    case OFPACT_PUSH_VLAN:
+		    case OFPACT_SET_ETH_SRC:
+		    case OFPACT_SET_ETH_DST:
+		    case OFPACT_SET_IPV4_SRC:
+		    case OFPACT_SET_IPV4_DST:
+		    case OFPACT_SET_IP_DSCP:
+		    case OFPACT_SET_IP_ECN:
+		    case OFPACT_SET_IP_TTL:
+		    case OFPACT_SET_L4_SRC_PORT:
+		    case OFPACT_SET_L4_DST_PORT:
+		    case OFPACT_REG_MOVE:
+		    case OFPACT_REG_LOAD:
+		    case OFPACT_STACK_PUSH:
+		    case OFPACT_STACK_POP:
+		    case OFPACT_DEC_TTL:
+		    case OFPACT_SET_MPLS_LABEL:
+		    case OFPACT_SET_MPLS_TC:
+		    case OFPACT_SET_MPLS_TTL:
+		    case OFPACT_DEC_MPLS_TTL:
+		    case OFPACT_PUSH_MPLS:
+		    case OFPACT_POP_MPLS:
+		    case OFPACT_SET_TUNNEL:
+		    case OFPACT_SET_QUEUE:
+		    case OFPACT_POP_QUEUE:
+		    case OFPACT_FIN_TIMEOUT:
+		    case OFPACT_RESUBMIT:
+		    case OFPACT_LEARN:
+		    case OFPACT_MULTIPATH:
+		    case OFPACT_NOTE:
+		    case OFPACT_EXIT:
+		    case OFPACT_SAMPLE:
+		    case OFPACT_METER:
+		    case OFPACT_CLEAR_ACTIONS:
+		    case OFPACT_WRITE_ACTIONS:
+		    case OFPACT_WRITE_METADATA:
+		    case OFPACT_GOTO_TABLE:
+		    case OFPACT_OUTPUT:
+		    default:
+			break;
+		    }
+		}
+
+		mrule->ofproto->ofproto_class->monitor_rule_modify_actions(mrule, true, subflow_collection_flag);
+	    }
+	}	
+    }
+    return error; 
+}
+
 
 /* OFPFC_DELETE implementation. */
 
@@ -4372,6 +5054,100 @@
     return error;
 }
 
+/* UMON: monitor table modifications. */
+static enum ofperr
+delete_monitor_flow_strict(struct ofproto *ofproto, struct ofconn *ofconn,
+			   const struct ofputil_monitor_mod *fmm,
+			   const struct ofp_header *request)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    struct rule_criteria criteria, monitor_criteria;
+    struct rule_collection rules, matching_rules;
+    struct monitor_rule_collection mrules;
+    enum ofperr error;
+    size_t i;
+    int j, k;
+    int rule_priority;
+
+    /* delete monitor rules from monitor table */
+    rule_criteria_init(&monitor_criteria, 0, &fmm->match, 0, htonll(0), htonll(0),
+                       OFPP_ANY, OFPG11_ANY);
+    error = collect_monitor_rules_strict(ofproto, &monitor_criteria, &mrules);    
+    if(!error && mrules.n > 0) {
+	for(i = 0; i < mrules.n; i++) {
+    	    rule_collection_init(&matching_rules);
+    	    ofproto->ofproto_class->collect_matching_forwarding_rules(mrules.rules[i], &matching_rules);
+	    for(j=0; j < matching_rules.n; j++){
+	        struct rule* forwarding_rule = matching_rules.rules[j];
+		struct monitor_rule_collection new_mrules;
+		monitor_rule_collection_init(&new_mrules);
+		for(k = 0; k < forwarding_rule->monitor_rules->n; k++) {
+			struct monitor_rule *mrule_ = forwarding_rule->monitor_rules->rules[k];
+			if (!cls_rule_equal(&mrules.rules[i]->cr, &mrule_->cr)) {
+				monitor_rule_collection_add(&new_mrules, mrule_);
+			}
+		}
+		monitor_rule_collection_destroy(forwarding_rule->monitor_rules);
+		monitor_rule_collection_init(forwarding_rule->monitor_rules);
+		for(k = 0; k < new_mrules.n; k++) {
+			monitor_rule_collection_add(forwarding_rule->monitor_rules, new_mrules.rules[k]);
+		}
+		monitor_rule_collection_destroy(&new_mrules);
+ 	    }
+	    rule_collection_destroy(&matching_rules);
+	    oftable_remove_monitor_rule(mrules.rules[i]); 
+	    ofproto->ofproto_class->monitor_rule_destruct(mrules.rules[i]);
+	    ofproto_monitor_rule_destroy__(mrules.rules[i]); 
+	}
+    }
+    if(error) {
+	goto exit;
+    }
+
+    rule_priority = ofproto->ofproto_class->calc_splitrule_priority_match((struct match*)&fmm->match);
+    if(rule_priority) {
+    	VLOG_INFO("delete monitor flow strict\n");
+    	/* delete splited monitor rules in oftable. */
+    	rule_criteria_init(&criteria, 0, &fmm->match, rule_priority, htonll(0), htonll(0),
+    	                   OFPP_ANY, OFPG11_ANY);
+    	error = collect_rules_strict(ofproto, &criteria, &rules);
+    	if(!error && rules.n > 0) {
+    	    error = delete_flows__(ofproto, ofconn, OFPUTIL_FF_NO_READONLY, request, &rules, OFPRR_DELETE);
+    	}
+    }
+
+exit:
+    rule_criteria_destroy(&criteria);
+    rule_collection_destroy(&rules);
+    monitor_rule_collection_destroy(&mrules);	
+    return error;
+}
+
+/* UMON: monitor table modifications. */
+static enum ofperr
+delete_monitor_micflows(struct ofproto *ofproto, const struct ofputil_monitor_mod *fmm)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    struct rule_criteria monitor_criteria;	
+    enum ofperr error;
+    struct monitor_rule_collection mrules;
+    int i;
+    
+    rule_criteria_init(&monitor_criteria, 0, &fmm->match, 0, htonll(0), htonll(0),
+                       OFPP_ANY, OFPG11_ANY);
+    error = collect_monitor_rules_strict(ofproto, &monitor_criteria, &mrules);
+    if(!error && mrules.n > 0) {
+        for(i = 0; i < mrules.n; i++) {
+	    ofproto->ofproto_class->monitor_rule_clear_micflows(mrules.rules[i]);
+	    ofproto->ofproto_class->monitor_rule_clear_stats(mrules.rules[i]);
+	    mrules.rules[i]->created = mrules.rules[i]->modified = time_msec();
+	}
+    }
+    rule_criteria_destroy(&monitor_criteria);
+    monitor_rule_collection_destroy(&mrules);
+    return error;
+}
+
 static void
 ofproto_rule_send_removed(struct rule *rule, uint8_t reason)
     OVS_REQUIRES(ofproto_mutex)
@@ -4502,12 +5278,18 @@
     OVS_EXCLUDED(ofproto_mutex)
 {
     enum ofperr error;
+    /* UMON: monitor table modifications. */
+    struct classifier *cls;
+    struct rule* new_rule;
+    bool add_flag = 0;
 
     ovs_mutex_lock(&ofproto_mutex);
     if (ofproto->n_pending < 50) {
         switch (fm->command) {
         case OFPFC_ADD:
             error = add_flow(ofproto, ofconn, fm, oh);
+	    if (!error)
+		add_flag = 1;
             break;
 
         case OFPFC_MODIFY:
@@ -4541,6 +5323,18 @@
     }
     ovs_mutex_unlock(&ofproto_mutex);
 
+/* UMON: monitor table modifications. */
+    if(add_flag) {
+        cls = &ofproto->tables[0].cls;
+    
+        fat_rwlock_rdlock(&cls->rwlock);
+        new_rule = rule_from_cls_rule(classifier_find_match_exactly(cls, &fm->match, OFP_DEFAULT_PRIORITY));
+        fat_rwlock_unlock(&cls->rwlock);
+        if(new_rule) {
+	    ofproto->ofproto_class->split_monitor_rules(new_rule);
+	}
+    }
+
     run_rule_executes(ofproto);
     return error;
 }
@@ -5489,6 +6283,7 @@
     return 0;
 }
 
+
 static void
 append_group_desc(struct ofgroup *group, struct list *replies)
 {
@@ -5811,6 +6606,79 @@
     }
 }
 
+/* UMON: monitor table modifications */
+static enum ofperr
+handle_monitor_mod(struct ofconn *ofconn, const struct ofp_header *oh)
+{
+    struct ofproto *ofproto = ofconn_get_ofproto(ofconn);
+    struct ofputil_monitor_mod fmm;
+    uint64_t ofpacts_stub[1024 / 8];
+    struct ofpbuf ofpacts;
+    int error = 0;
+
+    error = reject_slave_controller(ofconn);
+    if (error) {
+        goto exit;
+    }
+    ofpbuf_use_stub(&ofpacts, ofpacts_stub, sizeof ofpacts_stub);
+    error = ofputil_decode_monitor_mod(&fmm, oh, &ofpacts);
+    if (!error) {
+        error = ofproto_check_ofpacts(ofproto, fmm.ofpacts, fmm.ofpacts_len);
+    }
+    if (!error) {
+        error = handle_monitor_mod__(ofproto, ofconn, &fmm, oh);
+    }
+    if (error) {
+        goto exit_free_ofpacts;
+    }
+
+exit_free_ofpacts:
+    ofpbuf_uninit(&ofpacts);
+exit:
+    return error;
+}
+
+/* UMON: monitor table modifications */
+static enum ofperr
+handle_monitor_mod__(struct ofproto *ofproto, struct ofconn *ofconn,
+                     struct ofputil_monitor_mod * fmm, const struct ofp_header *oh)
+{
+    int error = 0;
+
+    switch(fmm->command) {
+    case OFPMMC_ADD:
+        error = add_monitor_flow(ofproto, fmm);
+        break;
+
+    case OFPMMC_MODIFY:
+        VLOG_INFO("doesn't support modify monitor flows loose.\n");
+        error = OFPERR_OFPMMC_BAD_COMMAND;
+        break;
+
+    case OFPMMC_MODIFY_STRICT:
+        error = modify_monitor_flow_strict(ofproto, fmm);
+        break;
+
+    case OFPMMC_DELETE:
+        VLOG_INFO("doesn't support delete monitor flows loose.\n");
+        break;
+
+    case OFPMMC_DELETE_STRICT:
+      	error = delete_monitor_flow_strict(ofproto, ofconn, fmm, oh);
+        break;
+
+    case OFPMMC_DELETE_MICFLOWS:
+	error = delete_monitor_micflows(ofproto, fmm);
+	break;
+
+    default:
+        error = OFPERR_OFPMMC_BAD_COMMAND;
+        break;
+    }
+    return error;
+
+}
+
 enum ofproto_table_config
 ofproto_table_get_config(const struct ofproto *ofproto, uint8_t table_id)
 {
@@ -6064,6 +6932,16 @@
     case OFPTYPE_BUNDLE_ADD_MESSAGE:
         return handle_bundle_add(ofconn, oh);
 
+    /* UMON: monitor table modifications */
+    case OFPTYPE_MONITOR_MOD:
+        return handle_monitor_mod(ofconn, oh);
+
+    /* UMON: monitor stats request. */
+    case OFPTYPE_MONITOR_STATS_REQUEST:
+	return handle_monitor_stats_request(ofconn, oh);
+	
+
+
     case OFPTYPE_HELLO:
     case OFPTYPE_ERROR:
     case OFPTYPE_FEATURES_REPLY:
@@ -6094,6 +6972,10 @@
     case OFPTYPE_TABLE_FEATURES_STATS_REQUEST:
     case OFPTYPE_TABLE_FEATURES_STATS_REPLY:
     case OFPTYPE_ROLE_STATUS:
+    /* UMON: prtscan detection alert. */
+    case OFPTYPE_PRTSCAN_ALERT:
+    /* UMON: monitor stats request. */
+    case OFPTYPE_MONITOR_STATS_REPLY:
     default:
         if (ofpmsg_is_stat_request(oh)) {
             return OFPERR_OFPBRC_BAD_STAT;
@@ -6903,6 +7785,27 @@
     oftable_remove_rule__(rule->ofproto, rule);
 }
 
+/* UMON: monitor table modifications. */
+static void
+oftable_remove_monitor_rule__(struct ofproto *ofproto, struct monitor_rule *mrule)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    struct classifier *cls = &ofproto->mtable->cls;
+
+    fat_rwlock_wrlock(&cls->rwlock);
+    classifier_remove(cls, CONST_CAST(struct cls_rule *, &mrule->cr));
+    fat_rwlock_unlock(&cls->rwlock);
+}
+
+
+/* UMON: monitor table modifications. */
+static void
+oftable_remove_monitor_rule(struct monitor_rule *mrule)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    oftable_remove_monitor_rule__(mrule->ofproto, mrule);
+}
+
 /* Inserts 'rule' into its oftable, which must not already contain any rule for
  * the same cls_rule. */
 static void
@@ -6936,7 +7839,20 @@
     fat_rwlock_unlock(&table->cls.rwlock);
     eviction_group_add_rule(rule);
 }
-
+
+/* UMON: monitor table modifications. */
+static void
+oftable_insert_monitor_rule(struct monitor_rule *mrule)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    struct ofproto *ofproto = mrule->ofproto;
+    struct oftable * table = ofproto->mtable;
+    fat_rwlock_wrlock(&table->cls.rwlock);
+    classifier_insert(&table->cls, CONST_CAST(struct cls_rule *, &mrule->cr));
+    fat_rwlock_unlock(&table->cls.rwlock);
+}
+
+
 /* unixctl commands. */
 
 struct ofproto *
diff -Naur openvswitch-2.3.2/ofproto/ofproto-dpif.c umon_ovs2.3/ofproto/ofproto-dpif.c
--- openvswitch-2.3.2/ofproto/ofproto-dpif.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-dpif.c	2016-06-23 10:15:38.680793681 -0400
@@ -14,7 +14,30 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
+/* UMON: portscan detections */
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 
 #include "ofproto/ofproto-dpif.h"
 #include "ofproto/ofproto-provider.h"
@@ -69,6 +92,10 @@
 #include "vlan-bitmap.h"
 #include "vlog.h"
 
+/* UMON: monitor table modifications. */
+#include "latch.h"
+#include "ovs-thread.h"
+
 VLOG_DEFINE_THIS_MODULE(ofproto_dpif);
 
 COVERAGE_DEFINE(ofproto_dpif_expired);
@@ -79,6 +106,80 @@
 
 struct flow_miss;
 
+/* UMON: montiro stats request */
+static void calc_micflow_duration(long long int start, long long int now,
+                          uint32_t *sec, uint32_t *nsec);
+/* UMON: prtscan detection alert. */
+static void
+monitor_rule_get_micflows(struct monitor_rule *mrule_, struct list *flows, int pkt_threshold, int byte_threshold);
+
+/* UMON: monitor table modifications. */
+struct monitor_flow_dump {
+    struct flow flow;           /* datapath micro flow */
+    long long int created;	/* created time of micro flow */
+    long long int modified;	/* modified time of micro flow */
+    struct dpif_flow_stats stats; /* corresponding stats */
+    struct ovs_mutex stats_mutex;
+    struct hmap_node node;       /* In 'struct monitor_flow_dump_collection' hmap micflows */
+};
+
+/* UMON: monitor table modifications. */
+static struct monitor_flow_dump *
+monitor_flow_dump_create(struct flow *flow)
+{
+    struct monitor_flow_dump *dump = xmalloc(sizeof(struct monitor_flow_dump));
+    memcpy(&dump->flow, flow, sizeof(struct flow));
+    ovs_mutex_init(&dump->stats_mutex);
+    dump->stats.n_packets = 0;
+    dump->stats.n_bytes = 0;
+    dump->created = dump->modified = time_msec(); 
+    return dump;
+}
+
+/* UMON: monitor table modifications. */
+struct flow * get_flow_from_dump(struct monitor_flow_dump *dump)
+{
+        return &dump->flow;
+}
+
+/* UMON: monitor table modifications. */
+struct hmap_node * get_node_from_dump(struct monitor_flow_dump *dump)
+{
+        return &dump->node;
+}
+
+/* UMON: monitor stats request */
+static void
+calc_micflow_duration(long long int start, long long int now,
+              uint32_t *sec, uint32_t *nsec)
+{
+    long long int msecs = now - start;
+    *sec = msecs / 1000;
+    *nsec = (msecs % 1000) * (1000 * 1000);
+}
+
+
+
+/* UMON: monitor table modifications. */
+struct monitor_rule_dpif {
+    struct monitor_rule up;
+    struct ovs_mutex micflow_mutex;
+    struct monitor_flow_dump_collection *flows OVS_GUARDED;
+    struct ovs_barrier thread_barrier;
+    /* These statistics:
+     *
+     *   - Do include packets and bytes from datapath flows which have not
+     *   recently been processed by a revalidator. */
+    struct ovs_mutex stats_mutex;
+    uint64_t packet_count OVS_GUARDED;	/* Number of packets received. */
+    uint64_t byte_count OVS_GUARDED;	/* Number of bytes received. */
+    long long int used OVS_GUARDED;
+    
+    size_t stat_count;			      /* size of monitor_stats. */
+    uint64_t *monitor_stats OVS_GUARDED;     /* monitor stats of monitor rules. */
+};
+
+
 struct rule_dpif {
     struct rule up;
 
@@ -96,6 +197,32 @@
 static void rule_get_stats(struct rule *, uint64_t *packets, uint64_t *bytes,
                            long long int *used);
 static struct rule_dpif *rule_dpif_cast(const struct rule *);
+/* UMON: monitor table modifications. */
+static struct monitor_rule_dpif *monitor_rule_dpif_cast(const struct monitor_rule *);
+
+/* UMON: monitor table modifications. */
+void
+monitor_flow_dump_collection_destroy(struct monitor_flow_dump_collection *flows)
+{
+    struct monitor_flow_dump *flow_, *next;
+    HMAP_FOR_EACH_SAFE (flow_, next, node, &flows->micflows) {
+        hmap_remove(&flows->micflows, &flow_->node);
+        free(flow_);
+	flows->n--;
+    }
+    hmap_destroy(&flows->micflows);
+    hmap_init(&flows->micflows);
+    flows->n = 0;
+}
+
+/* UMON: monitor table modifications. */
+struct monitor_flow_dump_collection * 
+get_dump_collection_from_rule(struct monitor_rule *mrule) 
+{
+    struct monitor_rule_dpif * mrule_ = monitor_rule_dpif_cast(mrule);
+    return mrule_->flows;
+}
+
 static void rule_expire(struct rule_dpif *);
 
 struct group_dpif {
@@ -278,6 +405,128 @@
     size_t max_mpls_depth;
 };
 
+/* UMON: monitor table modifications. */
+struct anomaly_detector {
+    struct ofproto_dpif *ofproto;    /* Parent ofproto.*/
+    pthread_t thread;		     /* Thread ID. */
+    char *name;			     /* Thread name. */
+
+    struct hmap portscan_dict;	     /* portscan detect keys,which are calculated from ip src and ip dst. */
+    struct hmap vertical_dict;	     /* vertical portscan detect keys, which are calculated by ip src and tcp dst port. */
+    struct sset vertical_attacks;    /* detected vertical attacks. */ 
+};
+
+/* UMON: monitor table modifications. */
+struct vscan_detector_args {
+    struct ofproto_dpif *ofproto;
+    struct monitor_rule_dpif *mrule;
+    struct hmap *vdict;
+    struct sset *detected_attacks;
+};
+
+/* UMON: monitor table modifications. */
+struct hscan_detector_args {
+    struct ofproto_dpif *ofproto;
+    struct monitor_rule_dpif *mrule;
+    struct hmap *hdict;
+};
+
+/* UMON: monitor table modifications. */
+struct portscan_key {
+        struct hmap_node hmap_node;     /* In parent anomaly_detector 'portscan_dict' map */
+        uint32_t key_hash;      /* portscan_dict keys*/
+        struct sset dst_ips;          /* the destination ports set*/
+};
+
+/* UMON: monitor table modifications. */
+struct portscan_vertical_key {
+        struct hmap_node hmap_node;     /* In parent anomaly_detector 'vertical_dict' */
+        uint32_t key_hash;              /* vertical dict keys */
+        struct sset dst_set;                    /*destinations set with the same tcp dst port*/
+};
+
+/* UMON: monitor table modifications. */
+static void
+portscan_key_delete(struct hmap *hdict, struct portscan_key *pkey)
+{
+        hmap_remove(hdict, &pkey->hmap_node);
+        free(pkey);
+}
+
+/* UMON: monitor table modifications. */
+static void
+portscan_vertical_key_delete(struct hmap *vdict, struct portscan_vertical_key *vkey)
+{
+        hmap_remove(vdict, &vkey->hmap_node);
+        free(vkey);
+}
+
+/* UMON: monitor table modifications. */
+static struct portscan_key *
+portscan_key_create(uint32_t hash)
+{
+        struct portscan_key *pkey = xmalloc(sizeof *pkey);
+
+        pkey->key_hash = hash;
+        sset_init(&pkey->dst_ips);
+        return pkey;
+}
+
+/* UMON: monitor table modifications. */
+static struct portscan_vertical_key *
+portscan_vertical_key_create(uint32_t hash)
+{
+        struct portscan_vertical_key *vkey = xmalloc(sizeof *vkey);
+
+        vkey->key_hash = hash;
+        sset_init(&vkey->dst_set);
+        return vkey;
+}
+
+/* UMON: monitor table modifications. */
+static size_t
+portscan_horizontal_key_credit(struct hmap *hdict, uint32_t hash_value, uint32_t dst_ip, struct portscan_key **ret_hkey)
+{
+        struct hmap_node * first_node;
+        struct portscan_key *pkey;
+        char dst_ip_char[32];
+
+        first_node = hmap_first_with_hash(hdict, hash_value);
+        sprintf(dst_ip_char,"%u", dst_ip);
+        if(first_node)
+                pkey = CONTAINER_OF(first_node, struct portscan_key, hmap_node);
+        else {
+                pkey = portscan_key_create(hash_value);
+                hmap_insert(hdict, &pkey->hmap_node, hash_value);
+        }
+
+        sset_add(&pkey->dst_ips, dst_ip_char);
+	*ret_hkey = pkey;
+        return sset_count(&pkey->dst_ips);
+}
+
+/* UMON: monitor table modifications. */
+static size_t
+portscan_vertical_key_credit(struct hmap *vdict, uint32_t hash_value,uint16_t dst, struct portscan_vertical_key **ret_vkey)
+{
+        struct hmap_node * first_node;
+	struct portscan_vertical_key *vkey;
+        char dst_char[32];
+
+        first_node = hmap_first_with_hash(vdict, hash_value);
+        sprintf(dst_char,"%u",dst);
+        if(first_node)
+                vkey = CONTAINER_OF(first_node, struct portscan_vertical_key, hmap_node);
+        else{
+                vkey = portscan_vertical_key_create(hash_value);
+                hmap_insert(vdict, &vkey->hmap_node, hash_value);
+        }
+        sset_add_port(&vkey->dst_set, dst_char);
+	*ret_vkey = vkey;
+	return sset_count(&vkey->dst_set);
+}
+
+
 /* All existing ofproto_backer instances, indexed by ofproto->up.type. */
 static struct shash all_dpif_backers = SHASH_INITIALIZER(&all_dpif_backers);
 
@@ -327,6 +576,11 @@
     struct guarded_list pins;      /* Contains "struct ofputil_packet_in"s. */
     struct seq *pins_seq;          /* For notifying 'pins' reception. */
     uint64_t pins_seqno;
+
+    /* UMON: monitor table modifications. */
+    struct anomaly_detector *detector;	/* Anomaly Detector thread ID. */
+    struct latch exit_latch;		/* Tell thread port scanning attack detector to exit. */
+    bool detector_thread_running;	/* Scanning detector running flag. */
 };
 
 /* All existing ofproto_dpif instances, indexed by ->up.name. */
@@ -375,6 +629,14 @@
     ofproto_flow_mod(&ofproto->up, fm);
 }
 
+/* UMON: prtscan detection alert */
+void
+ofproto_dpif_send_prtscan_alert(struct ofproto_dpif *ofproto,
+				struct ofputil_prtscan_alert *alert)
+{
+    connmgr_send_prtscan_alert(ofproto->up.connmgr, alert);
+}
+
 /* Appends 'pin' to the queue of "packet ins" to be sent to the controller.
  * Takes ownership of 'pin' and pin->packet. */
 void
@@ -489,6 +751,274 @@
     return NULL;
 }
 
+static void *
+hscan_detector(void *arg)
+{
+    struct hscan_detector_args *hargs = arg;
+    struct monitor_rule_dpif *mrule = hargs->mrule;
+    struct ofproto_dpif *ofproto = hargs->ofproto;
+    struct ofputil_prtscan_alert alert;
+    size_t i;
+
+    minimatch_expand(&mrule->up.cr.match, &alert.match);
+    calc_micflow_duration(mrule->up.created, mrule->up.modified, &alert.duration_sec, &alert.duration_nsec);
+    alert.stat_count = mrule->stat_count + 2;
+    alert.detection_type = 2;
+    alert.n_ports = 0;
+    alert.ports = NULL;
+    alert.n_attackers = 0;
+    alert.attackers = NULL;
+    alert.n_victims = 0;
+    alert.victims = NULL;
+    
+    ovs_mutex_lock(&mrule->stats_mutex);
+    alert.monitor_stats = (uint64_t*)xmalloc(sizeof(uint64_t)*alert.stat_count);
+    alert.monitor_stats[0] = mrule->packet_count;
+    alert.monitor_stats[1] = mrule->byte_count;    
+    for(i = 0; i < mrule->stat_count; i++) {
+        alert.monitor_stats[2+i] = mrule->monitor_stats[i];
+    }
+    ovs_mutex_unlock(&mrule->stats_mutex);
+    if(mrule->flows->n) {
+        list_init(&alert.flows);
+        monitor_rule_get_micflows(&mrule->up, &alert.flows, 0, 0);
+        alert.n_micflows = list_size(&alert.flows);
+        alert.monitor_stats[alert.stat_count-1] = alert.n_micflows;
+        while(alert.n_micflows >= 450) {
+            struct ofputil_prtscan_alert subalert;
+            memcpy(&subalert.match, &alert.match, sizeof(struct match));
+            subalert.duration_sec = alert.duration_sec;
+            subalert.duration_nsec = alert.duration_nsec;
+    	    subalert.detection_type = 2;
+            subalert.stat_count = alert.stat_count;
+            subalert.monitor_stats = (uint64_t*)xmalloc(sizeof(uint64_t)*subalert.stat_count);  
+            memcpy(subalert.monitor_stats, alert.monitor_stats, sizeof(uint64_t)*subalert.stat_count);
+    	    subalert.n_ports = 0;
+    	    subalert.ports = NULL;
+    	    subalert.n_attackers = 0;
+    	    subalert.attackers = NULL;
+    	    subalert.n_victims = 0;
+    	    subalert.victims = NULL;
+           
+            subalert.n_micflows = 450;
+            list_init(&subalert.flows); 
+            for(i = 0; i < 450; i++) {
+        	list_push_back(&subalert.flows, list_pop_front(&alert.flows));
+            }
+            alert.n_micflows -= 450;
+    	    ofproto_dpif_send_prtscan_alert(ofproto, &subalert);
+        }
+	if(alert.n_micflows) {
+            ofproto_dpif_send_prtscan_alert(ofproto, &alert);
+	}
+    } 
+    ovs_barrier_block(&mrule->thread_barrier);
+    ovs_mutex_lock(&mrule->micflow_mutex);
+    if(mrule->flows && mrule->flows->n && mrule->up.delete_flows == 1)
+        monitor_flow_dump_collection_destroy(mrule->flows);
+    ovs_mutex_unlock(&mrule->micflow_mutex);
+    ovs_mutex_lock(&mrule->stats_mutex);	
+    for(i = 0; i < mrule->stat_count; i++) {
+        mrule->monitor_stats[i] = 0;
+    }
+    ovs_mutex_unlock(&mrule->stats_mutex);	
+    return NULL;
+}
+
+
+static void *
+vscan_detector(void *arg)
+{
+    struct vscan_detector_args *vargs = arg;
+    struct monitor_rule_dpif *mrule = vargs->mrule;
+    struct hmap *vdict = vargs->vdict;
+    struct ofproto_dpif *ofproto = vargs->ofproto;
+    struct sset *detected_attacks = vargs->detected_attacks;
+    struct flow *dump_flow;
+    struct monitor_flow_dump *flow_;
+    struct flow_wildcards vertical_wc;
+    size_t dst_count, i;
+    uint64_t duration;
+    uint32_t hash_value;
+    uint16_t tp_dst;
+    struct ds match_ds;
+    FILE *fd;
+    struct timeval detected;
+
+    ds_init(&match_ds);
+    minimatch_format(&mrule->up.cr.match, &match_ds, OFP_DEFAULT_PRIORITY);
+    flow_wildcards_init_catchall(&vertical_wc);
+    memset(&vertical_wc.masks.nw_src, 0xff, sizeof vertical_wc.masks.nw_src);
+    memset(&vertical_wc.masks.nw_dst, 0xff, sizeof vertical_wc.masks.nw_dst);    
+    duration = mrule->up.anomaly_detection_interval;
+
+    ovs_mutex_lock(&mrule->micflow_mutex);
+    if(mrule->flows->n) {
+        HMAP_FOR_EACH(flow_, node, &mrule->flows->micflows) {
+            struct portscan_vertical_key *vkey = NULL;
+            struct ds port_str;
+	    char attack_hash[32];
+            dump_flow = get_flow_from_dump(flow_);
+            hash_value = flow_hash_in_wildcards(dump_flow, &vertical_wc, 0);
+	    sprintf(attack_hash, "%d", hash_value);
+	    if(sset_contains(detected_attacks, attack_hash))
+		continue;
+            tp_dst = ntohs(dump_flow->tp_dst);
+            dst_count = portscan_vertical_key_credit(vdict, hash_value, tp_dst, &vkey);
+            if(dst_count >= duration * mrule->up.vertical_threshold) {
+                struct ofputil_prtscan_alert alert;
+                struct ds attacker_ip_ds = DS_EMPTY_INITIALIZER;
+                struct ds victim_ip_ds = DS_EMPTY_INITIALIZER;
+                char *attacker_ip, *victim_ip;
+                char *port_number;
+	        
+	        sset_add(detected_attacks, attack_hash);
+                ds_put_format(&attacker_ip_ds, IP_FMT,IP_ARGS(dump_flow->nw_src));
+                ds_put_format(&victim_ip_ds, IP_FMT, IP_ARGS(dump_flow->nw_dst));
+                attacker_ip = ds_cstr(&attacker_ip_ds);
+                victim_ip = ds_cstr(&victim_ip_ds);
+                calc_micflow_duration(flow_->created, flow_->modified, &alert.duration_sec, &alert.duration_nsec);
+                alert.stat_count = mrule->stat_count + 2;
+                alert.detection_type = 1; /* 1 for vertical detection */
+                ovs_mutex_lock(&mrule->stats_mutex);
+                mrule->monitor_stats[mrule->stat_count - 1] = mrule->monitor_stats[mrule->stat_count - 1] + 1;
+        	alert.monitor_stats = (uint64_t*)xmalloc(sizeof(uint64_t)*alert.stat_count);
+        	alert.monitor_stats[0] = mrule->packet_count;
+        	alert.monitor_stats[1] = mrule->byte_count;    
+        	for(i = 0; i < mrule->stat_count; i++) {
+        	    alert.monitor_stats[2+i] = mrule->monitor_stats[i];
+        	}
+                ovs_mutex_unlock(&mrule->stats_mutex);  
+
+                alert.n_micflows = 0;
+        	alert.n_attackers = 1;
+        	alert.n_victims = 1;
+        	alert.attackers = (char*)xmalloc(alert.n_attackers*15*sizeof(char));
+        	memcpy(alert.attackers, attacker_ip, 15*sizeof(char));
+        	alert.victims = (char*)xmalloc(alert.n_victims*15*sizeof(char));
+        	memcpy(alert.victims, victim_ip, 15*sizeof(char));
+        	minimatch_expand(&mrule->up.cr.match, &alert.match);
+        	alert.n_ports = dst_count;
+        	alert.ports = (uint16_t*)xmalloc(alert.n_ports*sizeof(uint16_t));
+                ds_init(&port_str);
+                port_number = strtok(sset_pop(&vkey->dst_set),".");
+                alert.ports[0] = atoi(port_number);
+                ds_put_format(&port_str,"%s", port_number);
+                for(i=1; i<dst_count; i++) {
+          	    port_number = strtok(sset_pop(&vkey->dst_set),".");
+                    ds_put_format(&port_str, ", %s", port_number);
+        	    alert.ports[i] = atoi(port_number);
+                } 
+        	ofproto_dpif_send_prtscan_alert(ofproto, &alert);
+                VLOG_INFO("VERTICAL SCANNING DETECTED from "IP_FMT" to "IP_FMT" on ports: %s\n", IP_ARGS(dump_flow->nw_src), IP_ARGS(dump_flow->nw_dst), ds_cstr(&port_str));
+                sset_destroy(&vkey->dst_set);
+                portscan_vertical_key_delete(vdict, vkey);
+            }
+        }
+    }
+    ovs_mutex_unlock(&mrule->micflow_mutex);
+    ovs_barrier_block(&mrule->thread_barrier);
+    ovs_mutex_lock(&mrule->micflow_mutex);
+    if (mrule->flows && mrule->flows->n && mrule->up.delete_flows == 1)
+        monitor_flow_dump_collection_destroy(mrule->flows);
+    ovs_mutex_unlock(&mrule->micflow_mutex);
+    ovs_mutex_lock(&mrule->stats_mutex);	
+    for(i = 0; i < mrule->stat_count; i++) {
+        mrule->monitor_stats[i] = 0;
+    }
+    ovs_mutex_unlock(&mrule->stats_mutex);	
+    return NULL;
+}
+
+
+/* UMON: monitor table modifications. */
+static void *
+odpif_anomaly_detector(void *arg)
+{
+    struct anomaly_detector *detector = arg;
+    struct ofproto_dpif *ofproto = detector->ofproto;
+    struct oftable *mtable = ofproto->up.mtable;
+    struct cls_cursor cursor;
+    struct monitor_rule *mrule_, *next_rule;
+
+    detector->name = xasprintf("anomaly detector");
+    set_subprogram_name("%s", detector->name);
+    fat_rwlock_rdlock(&mtable->cls.rwlock);
+    cls_cursor_init(&cursor, &mtable->cls, NULL);
+    fat_rwlock_unlock(&mtable->cls.rwlock);
+
+    while(!latch_is_set(&ofproto->exit_latch)){
+	poll_timer_wait(5000);
+	poll_block();
+	CLS_CURSOR_FOR_EACH_SAFE(mrule_, next_rule, cr, &cursor) {	
+	    if(!mrule_->next_detection_time) {
+	        if(mrule_ && mrule_->detector_switch) {
+	            uint8_t type;
+	            int pos, old_pos = -1;
+	            struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+
+	            for(type = mrule_->prtscan_type; type; type=zero_rightmost_1bit(type)) {
+	                pos = rightmost_1bit_idx(type);
+	                switch(pos){
+	                case 0:
+	                    if((old_pos == 0 || old_pos != pos) && mrule->flows->n){
+	                        struct vscan_detector_args vargs;
+	                        vargs.mrule = mrule;
+	                        vargs.vdict = &detector->vertical_dict;
+			        vargs.ofproto = detector->ofproto;
+				vargs.detected_attacks = &detector->vertical_attacks;
+	                        ovs_thread_create("vscan detector", vscan_detector, (void*)&vargs);
+				poll_timer_wait(1000);
+				poll_block();
+	                    }
+	                    break;
+	                case 1:
+	                    if((old_pos == 0 || old_pos != pos) && mrule->flows->n){
+	            	    	struct hscan_detector_args hargs;
+	            	    	hargs.mrule = mrule;
+	            	    	hargs.hdict = &detector->portscan_dict;
+	            	    	hargs.ofproto = detector->ofproto;
+	            	    	ovs_thread_create("hscan detector", hscan_detector, (void *)&hargs);
+				poll_timer_wait(1000);
+				poll_block();
+	                    }
+	                    break;
+	                }
+	                old_pos = pos;
+	            }
+    		    mrule->up.next_detection_time = mrule->up.anomaly_detection_interval / 5;
+	        }
+	    } else {
+		mrule_->next_detection_time -= 1;
+	    }
+	}
+    }
+    return NULL;
+}
+
+static void
+prtscan_table_clean(struct ofproto *ofproto)
+{
+    struct oftable *mtable;
+    struct cls_cursor cursor;
+    struct monitor_rule *mrule_;
+
+    mtable = ofproto->mtable;
+    fat_rwlock_rdlock(&mtable->cls.rwlock);
+    cls_cursor_init(&cursor, &mtable->cls, NULL);
+    CLS_CURSOR_FOR_EACH(mrule_, cr, &cursor) {
+	if(mrule_->detector_switch && !mrule_->subflow_flag){
+	    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+	    ovs_mutex_lock(&mrule->micflow_mutex);
+	    if(mrule->flows && mrule->flows->n) {
+		monitor_flow_dump_collection_destroy(mrule->flows);
+	    } 
+	    ovs_mutex_unlock(&mrule->micflow_mutex);
+	}
+    }
+    fat_rwlock_unlock(&mtable->cls.rwlock); 
+}
+
 static int
 type_run(const char *type)
 {
@@ -1146,6 +1676,36 @@
     return n;
 }
 
+/* UMON: monitor table modifications. */
+static void
+prtscan_detector_switch(struct ofproto *ofproto_, bool switch_flag)
+{
+    struct ofproto_dpif *ofproto = ofproto_dpif_cast(ofproto_);
+    if (switch_flag && !ofproto->detector_thread_running) {
+	ofproto->detector = xzalloc(sizeof(struct anomaly_detector));
+	ofproto->detector->ofproto = ofproto;
+	hmap_init(&ofproto->detector->portscan_dict);
+	hmap_init(&ofproto->detector->vertical_dict);
+	sset_init(&ofproto->detector->vertical_attacks);
+	ofproto->detector_thread_running = true;
+	ofproto->detector->thread = ovs_thread_create("detecotor", odpif_anomaly_detector, ofproto->detector);
+	poll_timer_wait(1000);
+	poll_block();
+    } else if(!switch_flag && ofproto->detector_thread_running) {
+	struct anomaly_detector *detector = ofproto->detector;
+	latch_set(&ofproto->exit_latch);
+	xpthread_join(detector->thread, NULL);
+	prtscan_table_clean(ofproto_);  
+	hmap_destroy(&detector->portscan_dict);
+	hmap_destroy(&detector->vertical_dict);
+	sset_destroy(&detector->vertical_attacks);
+	latch_poll(&ofproto->exit_latch);
+	free(ofproto->detector);
+	ofproto->detector = NULL;
+	ofproto->detector_thread_running = false;
+    }
+}
+
 static int
 construct(struct ofproto *ofproto_)
 {
@@ -1212,6 +1772,12 @@
 
     ofproto->up.tables[TBL_INTERNAL].flags = OFTABLE_HIDDEN | OFTABLE_READONLY;
 
+    /* UMON: monitor table modifications. */
+    ofproto_init_mtable(ofproto_);
+    ofproto->detector = NULL;
+    ofproto->detector_thread_running = false;
+    latch_init(&ofproto->exit_latch);
+
     return error;
 }
 
@@ -1364,6 +1930,10 @@
     seq_destroy(ofproto->pins_seq);
 
     close_dpif_backer(ofproto->backer);
+
+    /* UMON: monitor table modifications. */
+    prtscan_detector_switch(ofproto_, false);
+    latch_destroy(&ofproto->exit_latch);
 }
 
 static int
@@ -3153,6 +3723,8 @@
 
     if (rule) {
         rule_dpif_credit_stats(rule, &stats);
+	/* UMON: monitor table modifications.*/
+	monitor_rule_dpif_credit_stats(rule, &stats, flow, &xout.wc);
     }
 
     xlate_in_init(&xin, ofproto, flow, rule, stats.tcp_flags, packet);
@@ -3192,6 +3764,359 @@
     ovs_mutex_unlock(&rule->stats_mutex);
 }
 
+/* UMON: monitor table modifications. */
+static void
+collect_monitor_rules(struct ofproto *ofproto, struct rule *rule_)
+{
+    struct oftable *table;
+    struct cls_cursor cursor;
+    struct monitor_rule *mrule;
+    unsigned long long int table_timestamp;
+    struct match mrule_match, rule_match;
+    struct flow_wildcards common_wc;
+    struct rule_dpif *rule = rule_dpif_cast(rule_);
+	
+    table = ofproto->mtable;
+    fat_rwlock_rdlock(&table->cls.rwlock);
+    atomic_read(&ofproto->mtable_timestamp, &table_timestamp);
+    cls_cursor_init(&cursor, &table->cls, NULL);
+    CLS_CURSOR_FOR_EACH(mrule, cr, &cursor) {
+	atomic_store(&rule->up.monitor_rule_timestamps, table_timestamp);
+        minimatch_expand(&mrule->cr.match, &mrule_match);
+        minimatch_expand(&rule->up.cr.match, &rule_match);
+	flow_wildcards_and(&common_wc, &mrule_match.wc, &rule_match.wc);
+	flow_zero_wildcards(&mrule_match.flow,&common_wc);
+	flow_zero_wildcards(&rule_match.flow,&common_wc);
+
+	if(flow_equal(&mrule_match.flow, &rule_match.flow)){
+	    monitor_rule_collection_add(rule->up.monitor_rules, mrule);
+	}
+    }
+    fat_rwlock_unlock(&table->cls.rwlock);
+}
+
+/* UMON: monitor table modifications. */
+static int
+calc_splitrule_priority_match(struct match* match) {
+    struct flow_wildcards *wc = &match->wc;
+    struct flow *f = &match->flow;
+    unsigned int ip_src_netmask = 0;
+    unsigned int ip_dst_netmask = 0;
+    unsigned int tp_src_netmask = 0;
+    unsigned int tp_dst_netmask = 0;
+    int priority = OFP_DEFAULT_PRIORITY;
+    if (wc->masks.nw_proto) {
+	if(f->nw_proto == IPPROTO_TCP || f->nw_proto == IPPROTO_UDP)
+	    priority += 2;
+        if(wc->masks.nw_src || wc->masks.nw_dst) {
+            if(wc->masks.nw_src){
+            	ip_src_netmask = count_1bits(wc->masks.nw_src);
+            }
+	    if(f->nw_src) {
+		priority += 1;
+	    }
+            if(wc->masks.nw_dst){
+            	ip_dst_netmask = count_1bits(wc->masks.nw_dst);
+            }
+	    if(f->nw_dst) {
+		priority += 1;
+	    }
+            if(wc->masks.tp_src){
+            	tp_src_netmask = count_1bits(wc->masks.tp_src);
+	    	if(f->tp_src) {
+	    	    tp_src_netmask += 1;
+	    	}
+            }
+            if(wc->masks.tp_dst){
+            	tp_dst_netmask = count_1bits(wc->masks.tp_dst);
+	    	if(f->tp_dst) {
+	    	    tp_dst_netmask += 1;
+	    	}
+            }
+            return priority + MAX(ip_src_netmask, ip_dst_netmask) + MAX(tp_src_netmask, tp_dst_netmask) + 1;
+        } else{
+            if(wc->masks.tp_src || wc->masks.tp_dst) {
+                memset(&wc->masks.tp_src, 0x00, sizeof wc->masks.tp_src);
+                memset(&wc->masks.tp_dst, 0x00, sizeof wc->masks.tp_dst);
+            }
+            return priority + 1;
+        }
+
+    } else {
+            return 0;
+    }
+}
+
+/* UMON: monitor table modifications. */
+static int
+calc_splitrule_priority(struct monitor_rule *mrule)
+{
+    struct match mrule_match;
+    const struct rule_actions *actions = monitor_rule_get_actions(mrule);
+    minimatch_expand(&mrule->cr.match, &mrule_match);
+
+    if (mrule->subflow_flag == 0) {
+	return calc_splitrule_priority_match(&mrule_match);
+    } else {
+	struct ofpact_monitor *ofm;
+	const struct ofpact * a;
+	OFPACT_FOR_EACH(a, actions->ofpacts, actions->ofpacts_len) {		
+	    if(a->type == OFPACT_MONITOR) {
+		ofm = ofpact_get_MONITOR(a);
+		return calc_splitrule_priority_match(&ofm->subflow_match);
+	    }
+	}
+	return 0;
+    }
+}
+
+
+/* UMON: monitor table modifications. */
+static void
+split_monitor_rules(struct rule *rule)
+	OVS_EXCLUDED(ofproto_mutex)
+{
+    struct match new_rule_match, rule_match;
+    struct minimatch rule_minimatch;
+    struct monitor_rule_dpif *mrule;
+    const struct rule_actions *new_rule_actions;
+
+    int i;
+    int priority;
+    new_rule_actions = rule_get_actions(rule);
+
+    if(rule->monitor_rules) {
+	for(i = 0; i < rule->monitor_rules->n; i++) {
+ 	    mrule = monitor_rule_dpif_cast(rule->monitor_rules->rules[i]);	
+ 	    minimatch_expand(&rule->cr.match, &rule_match);
+ 	    minimatch_expand(&mrule->up.cr.match,&new_rule_match);
+ 	    minimatch_init(&rule_minimatch, &new_rule_match);
+	    if(rule_match.flow.in_port.ofp_port) {
+    		memcpy(&new_rule_match.flow.in_port, &rule_match.flow.in_port, sizeof rule_match.flow.in_port);
+		memset(&new_rule_match.wc.masks.in_port, 0xff, sizeof new_rule_match.wc.masks.in_port);
+	    }
+ 	    flow_zero_wildcards(&rule_match.flow, &new_rule_match.wc);
+	    priority = calc_splitrule_priority(rule->monitor_rules->rules[i]);
+	    if(priority) {
+ 	    	if(cls_rule_is_loose_match(&mrule->up.cr,&rule_minimatch)){
+ 	            ofproto_add_flow(rule->ofproto, &new_rule_match, priority, new_rule_actions->ofpacts, new_rule_actions->ofpacts_len);
+ 	    	}
+	    }
+	}
+   }
+}
+
+/* UMON: monitor table modifications. */
+static void
+collect_matching_forwarding_rules(struct monitor_rule *mrule, struct rule_collection *rules)
+{
+    struct oftable *table;
+    struct rule *rule;
+    struct cls_cursor cursor;
+    unsigned long long int table_timestamp = 0;
+    struct match mrule_match, rule_match;
+    struct flow_wildcards common_wc;
+
+    table = &mrule->ofproto->tables[0];
+    cls_cursor_init(&cursor, &table->cls, NULL);
+    fat_rwlock_rdlock(&table->cls.rwlock);
+    CLS_CURSOR_FOR_EACH(rule, cr, &cursor) {
+	atomic_store(&rule->monitor_rule_timestamps, table_timestamp);
+	minimatch_expand(&mrule->cr.match, &mrule_match);
+        minimatch_expand(&rule->cr.match, &rule_match);
+	flow_wildcards_and(&common_wc, &mrule_match.wc, &rule_match.wc);
+        flow_zero_wildcards(&mrule_match.flow,&common_wc);
+        flow_zero_wildcards(&rule_match.flow,&common_wc);
+
+        if(flow_equal(&mrule_match.flow, &rule_match.flow)){
+	    if(!rule->monitor_rules){
+		rule->monitor_rules = xmalloc(sizeof(struct monitor_rule_collection));
+	        monitor_rule_collection_init(rule->monitor_rules);
+	    }
+	    monitor_rule_collection_add(rule->monitor_rules, mrule);
+	    rule_collection_add(rules, rule);
+	}
+    }	  
+    fat_rwlock_unlock(&table->cls.rwlock);
+}
+
+/* UMON: monitor table modifications. */
+static bool
+match_flow_tcp_flag(const struct flow * flow, int monitor_flag) {
+    bool match_flag = false;
+    switch(monitor_flag){
+    case OFPMT11_NONE:
+        match_flag = true;
+        break;
+    case OFPMT11_FIN:
+        if(ntohs(flow->tcp_flags) == 1)
+            match_flag = true;
+        break;
+    case OFPMT11_SYN:
+        if(ntohs(flow->tcp_flags) == 2)
+            match_flag = true;
+        break;
+    case OFPMT11_ACK:
+        if(ntohs(flow->tcp_flags) == 16)
+            match_flag = true;
+        break;
+    case OFPMT11_RST:
+        if(ntohs(flow->tcp_flags) == 4)
+            match_flag = true;
+        break;
+    case OFPMT11_FINACK:
+        if(ntohs(flow->tcp_flags) == 17)
+            match_flag = true;
+        break;
+    case OFPMT11_SYNACK:
+        if(ntohs(flow->tcp_flags) == 18)
+            match_flag = true;
+        break;
+    case OFPMT11_RSTACK:
+        if(ntohs(flow->tcp_flags) == 20)
+            match_flag = true;
+        break;
+    case OFPMT11_ICMP_ECHOREQ:
+        if((is_icmpv4(flow) || is_icmpv6(flow)) && ntohs(flow->tp_src) == 0)
+            match_flag = true;
+        break;
+    case OFPMT11_ICMP_ECHOREP:
+        if((is_icmpv4(flow) || is_icmpv6(flow)) && ntohs(flow->tp_src) == 8)
+            match_flag = true;
+        break;
+    }
+    return match_flag;
+}
+
+
+/* UMON: monitor table modifications. */
+void
+monitor_rule_dpif_credit_stats(struct rule_dpif *rule,
+			       const struct dpif_flow_stats *stats,
+			       const struct flow *flow,
+			       struct flow_wildcards *wc)
+{
+    struct monitor_rule_dpif *mrule;
+    int monitor_flag, i;
+    const struct rule_actions *actions;
+    const struct ofpact * a;
+    struct ofpact_monitor *ofm;
+    struct ofpact_prtscan_detection *ofpd;
+    struct flow * flow_copy;
+    uint32_t micflow_hash;
+    struct monitor_flow_dump *new_dump;
+    struct hmap_node * micflow_node;
+    struct flow_wildcards subflow_wc, micflow_wc;
+    bool match_flag = true;
+
+    flow_wildcards_init_catchall(&subflow_wc); 
+    if(rule->up.monitor_rules) {
+	/* setup flow_wildcards for datapath flows. */
+        for(i = 0; i < rule->up.monitor_rules->n; i++) {
+            mrule = monitor_rule_dpif_cast(rule->up.monitor_rules->rules[i]);
+            if(mrule && ( mrule->up.monitor_flag || mrule->up.subflow_flag || mrule->up.detector_switch)) {   
+                memset(&subflow_wc.masks.in_port, 0xff, sizeof subflow_wc.masks.in_port);
+                memset(&subflow_wc.masks.dl_type, 0xff, sizeof subflow_wc.masks.dl_type);
+
+                memset(&subflow_wc.masks.dl_src, 0xff, sizeof subflow_wc.masks.dl_src); 
+                memset(&subflow_wc.masks.dl_dst, 0xff, sizeof subflow_wc.masks.dl_dst);			
+		memset(&subflow_wc.masks.tcp_flags, 0xff, sizeof subflow_wc.masks.tcp_flags);
+
+                actions = monitor_rule_get_actions(&mrule->up);
+                OFPACT_FOR_EACH(a, actions->ofpacts, actions->ofpacts_len) {
+                    if(a->type == OFPACT_MONITOR) {
+                        ofm = ofpact_get_MONITOR(a);
+                        flow_wildcards_or(&subflow_wc, &ofm->subflow_match.wc, &subflow_wc);
+                    } else if(a->type == OFPACT_PRTSCAN_DETECTION) {
+			ofpd = ofpact_get_PRTSCAN_DETECTION(a);
+			flow_wildcards_or(&subflow_wc, &ofpd->submatch.wc, &subflow_wc);
+                    } 
+            	}
+            }
+        }
+        if(wc) {
+            flow_wildcards_or(wc, &subflow_wc, wc);
+        }
+
+        for(i = 0; i < rule->up.monitor_rules->n; i++) {
+	    bool match_exist = true;
+	    mrule = monitor_rule_dpif_cast(rule->up.monitor_rules->rules[i]);
+            /* credit monitor rule statistic count. */
+
+            if(mrule && minimatch_matches_flow(&mrule->up.cr.match, flow) && stats) { 
+                ovs_mutex_lock(&mrule->stats_mutex);
+                mrule->packet_count += stats->n_packets;
+                mrule->byte_count += stats->n_bytes;
+                mrule->used = MAX(mrule->used, stats->used);
+                if(mrule->up.monitor_flag) {
+		    match_exist = false;
+                    for(monitor_flag = (int)OFPMT11_FIN; monitor_flag != (int)OFPMT11_ICMP_ECHOREP << 1; monitor_flag = (int)monitor_flag << 1) {
+                        if(monitor_flag && ((int)monitor_flag & (int)mrule->up.monitor_flag)){
+			    match_flag = match_flow_tcp_flag(flow, monitor_flag);
+               	            if(match_flag) {
+               		        mrule->monitor_stats[rightmost_1bit_idx(monitor_flag)] += stats->n_packets;
+				mrule->up.modified = time_msec();	
+				match_exist = true;
+               	            } 
+                	}		
+                    }
+                }
+                ovs_mutex_unlock(&mrule->stats_mutex);
+
+                /* credit micflows if monitor rule collect subflow. */
+                if(mrule->flows && match_exist  && (mrule->up.subflow_flag || mrule->up.detector_switch)){
+
+    	            flow_copy = xmalloc(sizeof(struct flow));
+    	            memcpy(flow_copy, flow, sizeof(struct flow));
+    	            flow_wildcards_init_catchall(&micflow_wc);
+                    memset(&micflow_wc.masks.in_port, 0xff, sizeof micflow_wc.masks.in_port);
+                    memset(&micflow_wc.masks.dl_type, 0xff, sizeof micflow_wc.masks.dl_type);
+                    memset(&micflow_wc.masks.dl_src, 0xff, sizeof micflow_wc.masks.dl_src); 
+                    memset(&micflow_wc.masks.dl_dst, 0xff, sizeof micflow_wc.masks.dl_dst);                   
+                    memset(&micflow_wc.masks.tcp_flags, 0xff, sizeof micflow_wc.masks.tcp_flags);
+
+                    actions = monitor_rule_get_actions(&mrule->up);
+                    OFPACT_FOR_EACH(a, actions->ofpacts, actions->ofpacts_len) {
+                        if(a->type == OFPACT_MONITOR || a->type == OFPACT_PRTSCAN_DETECTION) {
+			    if(a->type == OFPACT_MONITOR) {
+	          	        ofm = ofpact_get_MONITOR(a);
+				if(ofm->subflow_flag)
+	                            flow_wildcards_or(&micflow_wc, &ofm->subflow_match.wc, &micflow_wc);
+			    } else {
+				ofpd = ofpact_get_PRTSCAN_DETECTION(a);
+				flow_wildcards_or(&micflow_wc, &ofpd->submatch.wc, &micflow_wc);
+			    }
+			}
+		    }
+
+                    flow_zero_wildcards(flow_copy, &micflow_wc);	
+               	    micflow_hash = flow_hash(flow_copy, 0);
+     	            ovs_mutex_lock(&mrule->micflow_mutex);
+	            micflow_node = hmap_first_with_hash(&mrule->flows->micflows,micflow_hash);
+               	    if(micflow_node) {
+               	        new_dump = CONTAINER_OF(micflow_node, struct monitor_flow_dump, node);
+		        new_dump->modified = time_msec(); 
+               	    } else {
+               	        new_dump = monitor_flow_dump_create(flow_copy);
+                        monitor_flow_dump_collection_add(mrule->flows, new_dump, micflow_hash);
+               	    }
+     	            ovs_mutex_unlock(&mrule->micflow_mutex);
+               	    /* credit stats to micflows. */
+                    if(stats){
+               	        ovs_mutex_lock(&new_dump->stats_mutex);
+               	        new_dump->stats.n_packets += stats->n_packets;
+               	        new_dump->stats.n_bytes += stats->n_bytes;
+               	        ovs_mutex_unlock(&new_dump->stats_mutex);
+                    }
+     	            free(flow_copy);
+                } 
+            } 
+        }	 
+    }
+    return;
+}
+
+
 ovs_be64
 rule_dpif_get_flow_cookie(const struct rule_dpif *rule)
     OVS_REQUIRES(rule->up.mutex)
@@ -3434,11 +4359,18 @@
     ofoperation_complete(rule->up.pending, 0);
 }
 
+
 static struct rule_dpif *rule_dpif_cast(const struct rule *rule)
 {
     return rule ? CONTAINER_OF(rule, struct rule_dpif, up) : NULL;
 }
 
+/* UMON: monitor table modifications. */
+static struct monitor_rule_dpif *monitor_rule_dpif_cast(const struct monitor_rule *mrule)
+{
+    return mrule ? CONTAINER_OF(mrule, struct monitor_rule_dpif, up) : NULL;
+}
+
 static struct rule *
 rule_alloc(void)
 {
@@ -3446,6 +4378,14 @@
     return &rule->up;
 }
 
+/* UMON: monitor table modifications. */
+static struct monitor_rule *
+monitor_rule_alloc(void)
+{
+    struct monitor_rule_dpif *mrule = xmalloc(sizeof *mrule);
+    return &mrule->up;
+}
+
 static void
 rule_dealloc(struct rule *rule_)
 {
@@ -3453,6 +4393,14 @@
     free(rule);
 }
 
+/* UMON: monitor table modifications. */
+static void 
+monitor_rule_dealloc(struct monitor_rule *mrule_)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    free(mrule);
+}
+
 static enum ofperr
 rule_construct(struct rule *rule_)
     OVS_NO_THREAD_SAFETY_ANALYSIS
@@ -3465,6 +4413,40 @@
     return 0;
 }
 
+/* UMON: monitor table modifications. */
+static enum ofperr
+monitor_rule_construct(struct monitor_rule *mrule_)
+    OVS_NO_THREAD_SAFETY_ANALYSIS
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    struct monitor_flow_dump_collection *flows;
+    size_t i;
+
+    ovs_mutex_init_adaptive(&mrule->stats_mutex);
+    mrule->packet_count = 0;
+    mrule->byte_count = 0;
+    mrule->used = mrule_->modified;
+    mrule->stat_count = 11;
+    mrule->monitor_stats = xmalloc(sizeof(uint64_t) * mrule->stat_count);
+    for(i = 0; i < mrule->stat_count; i++) {
+	mrule->monitor_stats[i] = 0;
+    }
+
+    if(mrule_->detector_switch){
+        ovs_barrier_init(&mrule->thread_barrier, count_1bits(mrule_->prtscan_type));    
+    }
+    ovs_mutex_init_adaptive(&mrule->micflow_mutex);
+    mrule->flows = NULL;
+    if(mrule_->subflow_flag == 1 || mrule_->detector_switch == 1) {
+	ovs_mutex_lock(&mrule->micflow_mutex);
+        flows = xmalloc(sizeof *flows) ;
+        monitor_flow_dump_collection_init(flows);
+	mrule->flows = flows;
+	ovs_mutex_unlock(&mrule->micflow_mutex);
+    }
+    return 0;
+}
+
 static void
 rule_insert(struct rule *rule_)
     OVS_REQUIRES(ofproto_mutex)
@@ -3473,6 +4455,7 @@
     complete_operation(rule);
 }
 
+
 static void
 rule_delete(struct rule *rule_)
     OVS_REQUIRES(ofproto_mutex)
@@ -3488,6 +4471,46 @@
     ovs_mutex_destroy(&rule->stats_mutex);
 }
 
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_destruct(struct monitor_rule *mrule_)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    ovs_mutex_destroy(&mrule->stats_mutex);
+    if(mrule_->subflow_flag == 1 || mrule_->detector_switch == 1) {
+	ovs_mutex_lock(&mrule->micflow_mutex);
+	monitor_flow_dump_collection_destroy(mrule->flows);	
+	ovs_mutex_unlock(&mrule->micflow_mutex);
+    }
+    ovs_mutex_destroy(&mrule->micflow_mutex);
+}
+
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_clear_micflows(struct monitor_rule *mrule_)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    ovs_mutex_lock(&mrule->micflow_mutex);
+    monitor_flow_dump_collection_destroy(mrule->flows);
+    ovs_mutex_unlock(&mrule->micflow_mutex);
+}
+
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_clear_stats(struct monitor_rule *mrule_)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    size_t i;
+
+    ovs_mutex_lock(&mrule->stats_mutex);
+    mrule->packet_count = 0;
+    mrule->byte_count = 0;
+    for(i = 0; i < mrule->stat_count; i++) {
+        mrule->monitor_stats[i] = 0;
+    }
+    ovs_mutex_unlock(&mrule->stats_mutex);
+}
+
 static void
 rule_get_stats(struct rule *rule_, uint64_t *packets, uint64_t *bytes,
                long long int *used)
@@ -3501,6 +4524,99 @@
     ovs_mutex_unlock(&rule->stats_mutex);
 }
 
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_get_stats(struct monitor_rule *mrule_, uint64_t *mstats, long long int *used)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    size_t i;
+    ovs_mutex_lock(&mrule->stats_mutex);
+    mstats[0] = mrule->packet_count;
+    mstats[1] = mrule->byte_count;    
+    for(i = 0; i < mrule->stat_count; i++) {
+	mstats[2+i] = mrule->monitor_stats[i];
+    }
+    *used = mrule->used;
+    ovs_mutex_unlock(&mrule->stats_mutex);
+
+    mstats[mrule->stat_count+2] = 0;
+    if(mrule->flows && (mrule_->subflow_flag || mrule_->detector_switch)){
+	ovs_mutex_lock(&mrule->micflow_mutex);
+        mstats[mrule->stat_count+2] = mrule->flows->n;
+        ovs_mutex_unlock(&mrule->micflow_mutex);
+    }
+}
+
+/* UMON: monitor stats request. */
+static void
+monitor_rule_get_micflows(struct monitor_rule *mrule_, struct list *flows, int pkt_threshold, int byte_threshold)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    struct monitor_flow_dump *dump;
+    struct match mrule_match;
+    int monitor_flag;
+    bool match_exist = true;
+
+    minimatch_expand(&mrule_->cr.match, &mrule_match);
+    list_init(flows);
+    if(mrule->flows) {
+        ovs_mutex_lock(&mrule->micflow_mutex);
+        HMAP_FOR_EACH(dump, node, &mrule->flows->micflows) {
+            if(mrule->up.monitor_flag) {
+                match_exist = false;
+                for(monitor_flag = OFPMT11_FIN; monitor_flag != OFPMT11_ICMP_ECHOREP; monitor_flag = monitor_flag << 1) {
+            	    if(monitor_flag && ((int)monitor_flag & (int)mrule->up.monitor_flag)){
+                        if(match_flow_tcp_flag(&dump->flow, monitor_flag)) {
+            		match_exist = true;
+            		break;
+            	    	}
+            	    }
+                }
+            }
+            if(match_exist && dump->stats.n_packets >= pkt_threshold && dump->stats.n_bytes >= byte_threshold) {
+                struct ofputil_monitor_micflow *micflow;
+                micflow = xmalloc(sizeof *micflow);
+                ovs_mutex_lock(&dump->stats_mutex);
+                micflow->tcp_flags = dump->flow.tcp_flags; 
+                micflow->packet_count = dump->stats.n_packets;
+                micflow->byte_count = dump->stats.n_bytes;
+                calc_micflow_duration(dump->created, dump->modified, &micflow->duration_sec, &micflow->duration_nsec);
+                ovs_mutex_unlock(&dump->stats_mutex);
+                
+                match_wc_init(&micflow->micflow_match, &dump->flow);
+                list_push_back(flows, &micflow->list_node);	
+            }
+        }
+        ovs_mutex_unlock(&mrule->micflow_mutex);
+    }
+}
+
+/* UMON: monitor stats request. */
+static void
+monitor_rule_get_stat_count(struct monitor_rule *mrule_, size_t *stat_count)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    ovs_mutex_lock(&mrule->stats_mutex);
+    *stat_count = mrule->stat_count + 3;
+    ovs_mutex_unlock(&mrule->stats_mutex);
+}
+
+
+/* UMON: monitor table modifications. */
+static void
+micflow_dump_format(struct ds *result, struct monitor_rule *mrule_)
+{
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+    struct monitor_flow_dump * dump;
+    HMAP_FOR_EACH(dump, node, &mrule->flows->micflows) {
+	flow_format(result, &dump->flow);
+	ds_put_format(result, ", duration=%llds, ", (dump->modified - dump->created) / 1000);
+	dpif_flow_stats_format(&dump->stats,result);
+	ds_put_cstr(result, "\n\t");
+    }
+    ds_put_char(result, '\n');
+}
+
 static void
 rule_dpif_execute(struct rule_dpif *rule, const struct flow *flow,
                   struct ofpbuf *packet)
@@ -3535,6 +4651,37 @@
     complete_operation(rule);
 }
 
+/* UMON: monitor table modifications. */
+static void
+monitor_rule_modify_actions(struct monitor_rule *mrule_, bool reset_counters, bool subflow_collection_flag)
+    OVS_REQUIRES(ofproto_mutex)
+{
+    size_t i;
+    struct monitor_rule_dpif *mrule = monitor_rule_dpif_cast(mrule_);
+
+
+    if (reset_counters) {
+	ovs_mutex_lock(&mrule->stats_mutex);
+	mrule->packet_count = 0;
+	mrule->byte_count = 0;
+	mrule->used = mrule_->modified;
+	mrule->stat_count = 11;
+	mrule->monitor_stats = xmalloc(sizeof(uint64_t) * mrule->stat_count);
+	for(i = 0; i < mrule->stat_count; i++) {
+	    mrule->monitor_stats[i] = 0;
+	}
+	ovs_mutex_unlock(&mrule->stats_mutex);
+
+	ovs_mutex_lock(&mrule->micflow_mutex);
+	if(mrule->flows && mrule->flows->n) {
+	    monitor_flow_dump_collection_destroy(mrule->flows);
+	}
+	mrule_->subflow_flag = subflow_collection_flag;
+	ovs_mutex_unlock(&mrule->micflow_mutex);
+
+    }
+}
+
 static struct group_dpif *group_dpif_cast(const struct ofgroup *group)
 {
     return group ? CONTAINER_OF(group, struct group_dpif, up) : NULL;
@@ -4933,6 +6080,7 @@
     return 0;
 }
 
+
 const struct ofproto_class ofproto_dpif_class = {
     init,
     enumerate_types,
@@ -4976,8 +6124,25 @@
     rule_destruct,
     rule_dealloc,
     rule_get_stats,
+    monitor_rule_alloc,         /* UMON: monitor table modifications. */
+    prtscan_detector_switch,    /* UMON: monitor table modifications. */
+    monitor_rule_construct,     /* UMON: monitor table modifications. */
+    monitor_rule_destruct,      /* UMON: monitor table modifications. */
+    monitor_rule_clear_micflows,      /* UMON: monitor table modifications. */
+    monitor_rule_clear_stats,      /* UMON: monitor table modifications. */
+    monitor_rule_dealloc,        /* UMON: monitor table modifications. */
+    monitor_rule_get_stats,     /* UMON: monitor table modifications. */
+    monitor_rule_get_micflows,	/* UMON: monitor stats request. */
+    monitor_rule_get_stat_count, /* UMON: monitor stats request. */
+    micflow_dump_format,	/* UMON: monitor table modifications. */
+    collect_monitor_rules,	/* UMON: monitor table modifications. */
+    calc_splitrule_priority_match,	/* UMON: monitor table modifications.*/
+    calc_splitrule_priority,	/* UMON: monitor table modifications. */
+    split_monitor_rules,	/* UMON: monitor table modifications. */
+    collect_matching_forwarding_rules,	/* UMON: monitor table modifications. */
     rule_execute,
     rule_modify_actions,
+    monitor_rule_modify_actions,	/* UMON: monitor table modifications. */
     set_frag_handling,
     packet_out,
     set_netflow,
diff -Naur openvswitch-2.3.2/ofproto/ofproto-dpif.h umon_ovs2.3/ofproto/ofproto-dpif.h
--- openvswitch-2.3.2/ofproto/ofproto-dpif.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-dpif.h	2016-06-23 10:15:51.704762868 -0400
@@ -12,6 +12,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License. */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFPROTO_DPIF_H
 #define OFPROTO_DPIF_H 1
 
@@ -117,6 +136,11 @@
 
 void rule_dpif_credit_stats(struct rule_dpif *rule ,
                             const struct dpif_flow_stats *);
+/* UMON: monitor table modifications */
+void monitor_rule_dpif_credit_stats(struct rule_dpif *rule,
+				    const struct dpif_flow_stats *,
+				    const struct flow *,
+				    struct flow_wildcards *);
 
 static inline bool rule_dpif_is_fail_open(const struct rule_dpif *);
 static inline bool rule_dpif_is_table_miss(const struct rule_dpif *);
@@ -165,6 +189,9 @@
 struct rule_dpif *ofproto_dpif_refresh_rule(struct rule_dpif *);
 
 struct ofport_dpif *odp_port_to_ofport(const struct dpif_backer *, odp_port_t);
+/* UMON: prtscan detection alert. */
+void ofproto_dpif_send_prtscan_alert(struct ofproto_dpif *,
+				     struct ofputil_prtscan_alert *);
 
 /*
  * Recirculation
@@ -248,7 +275,12 @@
                                    struct rule **rulep);
 int ofproto_dpif_delete_internal_flow(struct ofproto_dpif *, struct match *,
                                       int priority);
-
+
+/* UMON: monitor table modifications. */
+int ofproto_dpif_add_flow(struct ofproto_dpif *,
+			  const struct match *, int priority,
+			  const struct ofpact * ofpacts, int ofpacts_len);
+
 /* struct rule_dpif has struct rule as it's first member. */
 #define RULE_CAST(RULE) ((struct rule *)RULE)
 
diff -Naur openvswitch-2.3.2/ofproto/ofproto-dpif-upcall.c umon_ovs2.3/ofproto/ofproto-dpif-upcall.c
--- openvswitch-2.3.2/ofproto/ofproto-dpif-upcall.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-dpif-upcall.c	2016-06-23 10:16:07.072725455 -0400
@@ -12,6 +12,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "ofproto-dpif-upcall.h"
 
@@ -1274,7 +1293,8 @@
         xlate_cache_clear(ukey->xcache);
     }
     if (!ukey->xcache) {
-        ukey->xcache = xlate_cache_new();
+	/* UMON: monitor table modifications. */
+        ukey->xcache = xlate_cache_new(ofproto, &flow);
     }
 
     xlate_in_init(&xin, ofproto, &flow, NULL, push.tcp_flags, NULL);
diff -Naur openvswitch-2.3.2/ofproto/ofproto-dpif-xlate.c umon_ovs2.3/ofproto/ofproto-dpif-xlate.c
--- openvswitch-2.3.2/ofproto/ofproto-dpif-xlate.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-dpif-xlate.c	2016-06-23 10:16:20.656692176 -0400
@@ -12,6 +12,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License. */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 
 #include "ofproto/ofproto-dpif-xlate.h"
@@ -292,6 +311,9 @@
 
 struct xlate_cache {
     struct ofpbuf entries;
+    /* UMON: monitor table modifications. */
+    struct ofproto_dpif * ofproto;
+    struct flow flow;
 };
 
 static struct hmap xbridges = HMAP_INITIALIZER(&xbridges);
@@ -2040,6 +2062,8 @@
     if (ctx->xin->resubmit_stats) {
         rule_dpif_credit_stats(rule, ctx->xin->resubmit_stats);
     }
+    /* UMON: monitor table modifications. */
+    monitor_rule_dpif_credit_stats(rule, ctx->xin->resubmit_stats, &ctx->xin->flow, &ctx->xout->wc);
 
     ctx->resubmits++;
     ctx->recurse++;
@@ -3106,6 +3130,10 @@
         case OFPACT_SAMPLE:
             xlate_sample_action(ctx, ofpact_get_SAMPLE(a));
             break;
+
+	case OFPACT_MONITOR:
+	case OFPACT_PRTSCAN_DETECTION:
+	    break;
         }
     }
 }
@@ -3405,6 +3433,8 @@
         if (ctx.xin->resubmit_stats) {
             rule_dpif_credit_stats(rule, ctx.xin->resubmit_stats);
         }
+	/* UMON: monitor table modifications. */
+	monitor_rule_dpif_credit_stats(rule, ctx.xin->resubmit_stats, flow, wc);
         if (ctx.xin->xcache) {
             struct xc_entry *entry;
 
@@ -3629,12 +3659,17 @@
                                         packet);
 }
 
+/* UMON: monitor table modifications. */
 struct xlate_cache *
-xlate_cache_new(void)
+xlate_cache_new(struct ofproto_dpif *ofproto, struct flow *flow)
 {
     struct xlate_cache *xcache = xmalloc(sizeof *xcache);
 
     ofpbuf_init(&xcache->entries, 512);
+    /* UMON: monitor table modifications. */
+    xcache->ofproto = ofproto;
+    memcpy(&xcache->flow, flow, sizeof(struct flow));
+
     return xcache;
 }
 
@@ -3696,6 +3731,8 @@
         switch (entry->type) {
         case XC_RULE:
             rule_dpif_credit_stats(entry->u.rule, stats);
+	    /* UMON: monitor table modifications. */
+	    monitor_rule_dpif_credit_stats(entry->u.rule, stats, &xcache->flow, NULL);
             break;
         case XC_BOND:
             bond_account(entry->u.bond.bond, entry->u.bond.flow,
diff -Naur openvswitch-2.3.2/ofproto/ofproto-dpif-xlate.h umon_ovs2.3/ofproto/ofproto-dpif-xlate.h
--- openvswitch-2.3.2/ofproto/ofproto-dpif-xlate.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-dpif-xlate.h	2016-06-23 10:16:36.664654373 -0400
@@ -12,6 +12,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License. */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFPROTO_DPIF_XLATE_H
 #define OFPROTO_DPIF_XLATE_H 1
 
@@ -186,7 +205,9 @@
 
 int xlate_send_packet(const struct ofport_dpif *, struct ofpbuf *);
 
-struct xlate_cache *xlate_cache_new(void);
+/* UMON: monitor table modifications. */
+struct xlate_cache *xlate_cache_new(struct ofproto_dpif *, struct flow *flow);
+
 void xlate_push_stats(struct xlate_cache *, bool may_learn,
                       const struct dpif_flow_stats *);
 void xlate_cache_clear(struct xlate_cache *);
diff -Naur openvswitch-2.3.2/ofproto/ofproto.h umon_ovs2.3/ofproto/ofproto.h
--- openvswitch-2.3.2/ofproto/ofproto.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto.h	2016-06-23 10:16:52.312616970 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFPROTO_H
 #define OFPROTO_H 1
 
@@ -390,6 +409,9 @@
 bool ofproto_has_snoops(const struct ofproto *);
 void ofproto_get_snoops(const struct ofproto *, struct sset *);
 void ofproto_get_all_flows(struct ofproto *p, struct ds *);
+/* UMON: monitor table modifications. */
+void ofproto_get_all_monitor_flows(struct ofproto *p, struct ds *);
+
 void ofproto_get_netflow_ids(const struct ofproto *,
                              uint8_t *engine_type, uint8_t *engine_id);
 
diff -Naur openvswitch-2.3.2/ofproto/ofproto-provider.h umon_ovs2.3/ofproto/ofproto-provider.h
--- openvswitch-2.3.2/ofproto/ofproto-provider.h	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/ofproto/ofproto-provider.h	2016-06-23 10:17:05.856584945 -0400
@@ -14,6 +14,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #ifndef OFPROTO_OFPROTO_PROVIDER_H
 #define OFPROTO_OFPROTO_PROVIDER_H 1
 
@@ -54,6 +73,8 @@
 struct ofputil_flow_mod;
 struct bfd_cfg;
 struct meter;
+/* UMON: monitor table modifications. */
+struct monitor_flow_dump;
 
 extern struct ovs_mutex ofproto_mutex;
 
@@ -88,6 +109,10 @@
     struct hmap ofport_usage;   /* Map ofport to last used time. */
     uint64_t change_seq;        /* Change sequence for netdev status. */
 
+    /* UMON: Monitor table. */
+    struct oftable *mtable;     /* For monitor rules. */
+    atomic_ullong mtable_timestamp ;    /* Monitor table timestamp when last modified. */
+
     /* Flow tables. */
     long long int eviction_group_timer; /* For rate limited reheapification. */
     struct oftable *tables;
@@ -150,6 +175,9 @@
     struct ofputil_group_features ogf;
 };
 
+/* UMON: monitor table modifications. */
+void ofproto_init_mtable(struct ofproto *);
+
 void ofproto_init_tables(struct ofproto *, int n_tables);
 void ofproto_init_max_ports(struct ofproto *, uint16_t max_ports);
 
@@ -326,6 +354,74 @@
  *      'rule->mutex', and safely written only by coding holding ofproto_mutex
  *      AND 'rule->mutex'.  These are marked OVS_GUARDED.
  */
+
+/* UMON: monitor table modifications. */
+struct monitor_rule_collection {
+    struct monitor_rule **rules;    /* The monitor rules. */
+    size_t n;			    /* Number of monitor rules collected. */
+   
+    size_t capacity;		    /* Number of rules that fit in 'rules'. */
+    struct monitor_rule *stub[64];  /* Preallocated rules to avoid malloc(). */
+};
+/* UMON: functions related to monitor_rule_collection. */
+void monitor_rule_collection_init(struct monitor_rule_collection *);
+void monitor_rule_collection_add(struct monitor_rule_collection *, struct monitor_rule *);
+void monitor_rule_collection_ref(struct monitor_rule_collection *) OVS_REQUIRES(ofproto_mutex);
+void monitor_rule_collection_unref(struct monitor_rule_collection *);
+void monitor_rule_collection_destroy(struct monitor_rule_collection *);
+
+/* UMON: monitor mic-flows */
+/* A set of flows that match some monitor collect microflow rules */
+struct monitor_flow_dump_collection {
+    size_t n;                   /* Number of flows collected. */
+    struct hmap micflows;       /* the mic flows. */
+};
+
+
+/* UMON: monitor table modifications. */
+struct flow * get_flow_from_dump(struct monitor_flow_dump *);
+struct hmap_node * get_node_from_dump(struct monitor_flow_dump *);
+
+/* UMON: monitor table modifications. */
+/* functions related to struct monitor_flow_dump_collection. */
+void monitor_flow_dump_collection_init(struct monitor_flow_dump_collection *);
+void monitor_flow_dump_collection_add(struct monitor_flow_dump_collection *, struct monitor_flow_dump *, uint32_t hash);
+void monitor_flow_dump_collection_destroy(struct monitor_flow_dump_collection *);
+struct monitor_flow_dump_collection * get_dump_collection_from_rule(struct monitor_rule *);
+
+
+/* UMON: monitor table modifications. */
+struct monitor_rule {
+
+    struct ofproto *const ofproto;   /* The ofproto that contains this monitor rule. */
+    const struct cls_rule cr;   /* In owning ofproto's classifier. */
+    struct ovs_mutex mutex OVS_ACQ_AFTER(ofproto_mutex);
+    /* Timeouts. */
+    uint16_t hard_timeout OVS_GUARDED; /* In seconds from ->modified. */
+    uint16_t idle_timeout OVS_GUARDED; /* In seconds from ->used. */
+
+    OVSRCU_TYPE(const struct rule_actions *) monitor_actions OVS_GUARDED; /* monitor actions. */
+    uint8_t  delete_flows;		/* whether delete subflows. */
+    uint8_t  detector_switch;           /* whether anomaly detector is on/off */
+    enum ofp11_prtscan_type prtscan_type;   /* port scanning detection type. */
+    uint64_t anomaly_detection_interval;    /* frequency intervals for anomaly detection thread. */
+    uint16_t vertical_threshold;	    /* Threshold of vertical scanning detection. */
+    uint16_t horizontal_threshold;	    /* Threshold of horizontal scanning detecion. */
+    int next_detection_time;
+
+    enum ofp11_monitor_type monitor_flag;   /* monitor flag type. */
+    uint8_t subflow_flag;		    /* subflow monitor flag. */
+    struct ovs_refcount ref_count;
+    long long int created OVS_GUARDED; /* Creation time. */
+    long long int modified OVS_GUARDED; /* Last modified time.*/
+};
+void ofproto_monitor_rule_ref(struct monitor_rule *);
+void ofproto_monitor_rule_unref(struct monitor_rule *);
+
+static inline const struct rule_actions * monitor_rule_get_actions(const struct monitor_rule *);
+
+
+
 struct rule {
     /* Where this rule resides in an OpenFlow switch.
      *
@@ -369,6 +465,11 @@
     struct eviction_group *eviction_group OVS_GUARDED_BY(ofproto_mutex);
     struct heap_node evg_node OVS_GUARDED_BY(ofproto_mutex);
 
+    /* UMON: monitor rule collections for each Openflow routing rule*/
+    struct monitor_rule_collection *monitor_rules OVS_GUARDED;
+    /* UMON: monitor table modifications. */
+    atomic_ullong monitor_rule_timestamps OVS_GUARDED;
+
     /* OpenFlow actions.  See struct rule_actions for more thread-safety
      * notes. */
     OVSRCU_TYPE(const struct rule_actions *) actions;
@@ -455,6 +556,8 @@
 extern size_t n_handlers, n_revalidators;
 
 static inline struct rule *rule_from_cls_rule(const struct cls_rule *);
+/* UMON: monitor table modifications. */
+static inline struct monitor_rule *monitor_rule_from_cls_rule(const struct cls_rule *);
 
 void ofproto_rule_expire(struct rule *rule, uint8_t reason)
     OVS_REQUIRES(ofproto_mutex);
@@ -1266,6 +1369,26 @@
                            uint64_t *byte_count, long long int *used)
         /* OVS_EXCLUDED(ofproto_mutex) */;
 
+    /* UMON: monitor table modifications. */
+    struct monitor_rule *(*monitor_rule_alloc)(void);
+    void (*prtscan_detector_switch)(struct ofproto *, bool switch_flag);
+    enum ofperr (*monitor_rule_construct)(struct monitor_rule *mrule);
+    void (*monitor_rule_destruct)(struct monitor_rule *mrule);
+    void (*monitor_rule_clear_micflows)(struct monitor_rule *mrule);
+    void (*monitor_rule_clear_stats)(struct monitor_rule *mrule);
+    void (*monitor_rule_dealloc)(struct monitor_rule *mrule);
+
+    void (*monitor_rule_get_stats)(struct monitor_rule *mrule, uint64_t *mstats, long long int *used); 
+    void (*monitor_rule_get_micflows)(struct monitor_rule *mrule, struct list *flows, int pkt_threshold, int byte_threshold);
+    void (*monitor_rule_get_stat_count)(struct monitor_rule *mrule_, size_t *stat_count);
+    void (*micflow_dump_format)(struct ds *, struct monitor_rule *); 
+    /* UMON: monitor table modifications. */
+    void (*collect_monitor_rules)(struct ofproto *, struct rule *);
+    int (*calc_splitrule_priority_match) (struct match *);
+    int (*calc_splitrule_priority)(struct monitor_rule *);
+    void (*split_monitor_rules)(struct rule *) OVS_EXCLUDED(ofproto_mutex);
+    void (*collect_matching_forwarding_rules)(struct monitor_rule *, struct rule_collection *);
+
     /* Applies the actions in 'rule' to 'packet'.  (This implements sending
      * buffered packets for OpenFlow OFPT_FLOW_MOD commands.)
      *
@@ -1312,6 +1435,9 @@
      * rule. */
     void (*rule_modify_actions)(struct rule *rule, bool reset_counters)
         /* OVS_REQUIRES(ofproto_mutex) */;
+    /* UMON: monitor table modifications. */
+    void (*monitor_rule_modify_actions)(struct monitor_rule *mrule, bool reset_counters, bool subflow_collection_flag)
+       /* OVS_REQUIRES(ofproto_mutex) */;
 
     /* Changes the OpenFlow IP fragment handling policy to 'frag_handling',
      * which takes one of the following values, with the corresponding
@@ -1725,7 +1851,13 @@
     OVS_EXCLUDED(ofproto_mutex);
 void ofproto_flush_flows(struct ofproto *);
 
-
+/* UMON: monitor table modifications. */
+static inline const struct rule_actions *
+monitor_rule_get_actions(const struct monitor_rule *mrule)
+{
+    return ovsrcu_get(const struct rule_actions *, &mrule->monitor_actions);
+}
+
 static inline const struct rule_actions *
 rule_get_actions(const struct rule *rule)
 {
@@ -1750,4 +1882,11 @@
     return cls_rule ? CONTAINER_OF(cls_rule, struct rule, cr) : NULL;
 }
 
+/* UMON: monitor table modifications. */
+static inline struct monitor_rule *
+monitor_rule_from_cls_rule(const struct cls_rule *cls_rule)
+{
+    return cls_rule ? CONTAINER_OF(cls_rule, struct monitor_rule, cr) : NULL;
+}
+
 #endif /* ofproto/ofproto-provider.h */
diff -Naur openvswitch-2.3.2/vswitchd/bridge.c umon_ovs2.3/vswitchd/bridge.c
--- openvswitch-2.3.2/vswitchd/bridge.c	2015-06-18 15:32:47.000000000 -0400
+++ umon_ovs2.3/vswitchd/bridge.c	2016-06-23 10:17:19.232552468 -0400
@@ -13,6 +13,25 @@
  * limitations under the License.
  */
 
+/**
+ * This project was developed at the George Mason University for research purposes.
+ * Pursuant to title 17 Section 105 of the United
+ * States Code this project is not subject to copyright protection and
+ * is in the public domain.
+ * 
+ * GMU assumes no responsibility whatsoever for its use by other parties,
+ * and makes no guarantees, expressed or implied, about its quality,
+ * reliability, or any other characteristic.
+ * 
+ * We would appreciate acknowledgment if the project is used.
+ * 
+ * GMU ALLOWS FREE USE OF THIS PROJECT IN ITS "AS IS" CONDITION AND
+ * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM THE USE OF THIS PROJECT.
+ *
+ */
+
 #include <config.h>
 #include "bridge.h"
 #include <errno.h>
@@ -211,6 +230,9 @@
 static void bridge_create(const struct ovsrec_bridge *);
 static void bridge_destroy(struct bridge *);
 static struct bridge *bridge_lookup(const char *name);
+/* UMON: monitor table modifications. */
+static unixctl_cb_func bridge_unixctl_dump_monitor_flows;
+
 static unixctl_cb_func bridge_unixctl_dump_flows;
 static unixctl_cb_func bridge_unixctl_reconnect;
 static size_t bridge_get_controllers(const struct bridge *br,
@@ -440,6 +462,10 @@
                              qos_unixctl_show, NULL);
     unixctl_command_register("bridge/dump-flows", "bridge", 1, 1,
                              bridge_unixctl_dump_flows, NULL);
+    /* UMON: monitor table modifications. */
+    unixctl_command_register("bridge/dump-monitor-flows", "bridge", 1, 1,
+                             bridge_unixctl_dump_monitor_flows, NULL);
+
     unixctl_command_register("bridge/reconnect", "[bridge]", 0, 1,
                              bridge_unixctl_reconnect, NULL);
     lacp_init();
@@ -2741,6 +2767,27 @@
 
     unixctl_command_reply(conn, ds_cstr(&results));
     ds_destroy(&results);
+}
+
+/* UMON: monitor table modifications. */
+static void
+bridge_unixctl_dump_monitor_flows(struct unixctl_conn *conn, int argc OVS_UNUSED,
+                                  const char *argv[], void *aux OVS_UNUSED)
+{
+    struct bridge *br;
+    struct ds results;
+
+    br = bridge_lookup(argv[1]);
+    if(!br) {
+            unixctl_command_reply_error(conn, "Unknown bridge");
+            return;
+    }
+
+    ds_init(&results);
+    ofproto_get_all_monitor_flows(br->ofproto,&results);
+
+    unixctl_command_reply(conn, ds_cstr(&results));
+    ds_destroy(&results);
 }
 
 /* "bridge/reconnect [BRIDGE]": makes BRIDGE drop all of its controller
